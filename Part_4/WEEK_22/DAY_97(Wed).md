# DAY 97

## 목차
- [캐시 모니터링](#캐시-모니터링)
- [캐시 문제](#캐시-문제)
- [분산 캐시](#분산-캐시)
- [Redis](#redis)
- [분산 캐시 패턴](#분산-캐시-패턴)
- [분산 캐시 고려사항](#분산-캐시-고려사항)

---

## 캐시 모니터링
- Spring Boot Actuator
  + 캐시의 Hit/Miss 비율, 캐시 크기, 만료 정책 등의 캐시 통계 정보까지도 노출할 수 있음
 
| 엔드포인트 | 설명 |
|-|-|
| /actuator/caches | 현재 등록된 모든 캐시 이름과 상태 정보를 조회합니다. |
| /actuator/caches/{cacheName} | 특정 캐시의 내부 상태를 확인합니다. |
| /actuator/metrics/cache.gets | 캐시 Hit/Miss 통계를 조회합니다. |
| /actuator/metrics/cache.puts | 캐시 저장(Put) 이벤트 통계를 조회합니다. |
| /actuator/metrics/cache.evictions | 캐시 항목 제거(Eviction) 횟수를 조회합니다. |

#### 캐시 성능 지표의 중요성
+ 적중률 : 캐시에서 데이터를 성공적으로 반환 비율
+ 미적중률 : 캐시가 데이터를 찾지 못해 원본 데이터 소스를 조회한 비율
+ 제거 횟수 : 용량 초과 또는 만료로 제거된 항목의 수
+ 로딩 시간 : 캐시 미적중 시 데이터를 새로 불러오는 데 걸린 시간
+ 메모리 사용량 : 캐시 데이터가 차지하는 메모리의 크기
  + 캐시는 메모리에 데이터 저장 Heap 영역을 지속적으로 점유
  + JVM의 메모리 사용량을 함께 모니터링 해야함
 
+ 잘못된 설계는 병목 현상을 일으킬 수 있음
  + 단일 캐시 키 집중 -> 모든 요청이 동일한 캐시 키를 공유
  + TTL 동시 만료 -> 캐시 항목이 한꺼번에 만료되어 DB 부하 증가
  + 과도한 캐시 락 -> 여러 스레드가 동시에 캐시 로드를 시도
 
## 캐시 문제
#### 캐시 폭발
- 다수의 요청이 동시에 캐시 미스를 발생시켜 DB나 원본 서버에 과도한 부하를 주는 현상
- 원인과 영향
  + TTL 만료 : 캐시가 동시에 만료되어 모든 요청이 DB로 향함
  + Lock 미적용 : 캐시가 비어 있을 때 여러 요청이 동시에 DB 접근
  + 대용량 트래픽 : 인기 데이터의 만료 시점에 요청 폭증
 
- 방지 전략
  - 분산 만료
    + TTL을 랜덤하게 설정하여 캐시 만료 시점을 분산
    + 모든 캐시가 한 번에 만료되지 않도록 하여 폭발 위험을 완화
   
  - 캐시 재갱신 잠금 (Lock)
    - 한 요청만 DB 접근을 허용하고, 나머지는 대기
    - 동시에 여러 스레드가 동일한 데이터를 갱신하지 않도록 방지
   
  - 백그라운드 캐시 갱신
    - 캐시 만료 전에 백그라운드에서 미리 데이터를 갱신
    - 사용자는 항상 최신 데이터에 빠르게 접근할 수 있음
   
#### 캐시 누수
- 캐시가 더 이상 사용되지 않는 데이터를 계속 메모리에 보관하여 Heap 메모리 부족을 유발하는 현상
- 원인과 증상
  + TTL 미설정 : 캐시 항목이 영구적으로 메모리에 남음
  + 크기 제한 누락 : 캐시 최대 크기가 없어 무한히 저장됨
  + 약한 참조 미사용 : GC가 캐시 항목을 해제하지 못함
    + weakKeys(), weakVaues()
    + GC가 참조되지 않는 객체를 자동으로 제거하도록 설정
   
#### 캐시 오염
- 자주 사용되지 않는 데이터가 캐시에 저장되어, 자주 사용하는 데이터가 밀려나는 현상
- 원인과 현상
  + LRU 정책 한계 : 접근 빈도가 낮은 항목이 최근 접근으로 인해 유지됨
  + 캐시 Key 설계 오류 : 비효율적인 Key 생성으로 동일 데이터 중복 저장
  + 인기 데이터 식별 실패 : 중요한 데이터가 우선순위를 받지 못함
  + Hit Ratio가 감소, 전체 성능 저하
 
- 방지 전략
  - LFU 정책 활용
    + Caffeine은 내부적으로 LFU 기반의 접근 빈도 추적 알고리즘 사용
    + 자주 사용되는 항목은 오래 유지되고, 드문 데이터는 자동 제거 됨
  - 캐시 Key 최적화
    + Key에 의미 있는 식별자를 포함시켜 중복 캐싱 방지
    + 동일 제ㅜㅍㅁ이더라도 지역별 데이터가 구분되어 저장 됨
 
#### 무한 캐싱
- 캐시 항목에 TTL이 설정되지 않아, 데이터가 영구적으로 저장되는 현상
- 원인과 문제
  + TTL 설정 누락 : 캐시 항목이 만료되지 않음
  + 정적 데이터로 오인 : 업데이트 주기가 존재하는 데이터에 TTL 미적용
  + 모니터링 부재 : 캐시 사용량 증가를 인지하지 못함
  + 오래된 데이터가 유지되면서 데이터 불일치가 발생할 수 있음
 
- 해결 방법
  + TTL 정책 적용
  + 주기적 캐시 정리
 
## 분산 캐시
- 여러 서버가 동일한 캐시 데이터를 공유할 수 있도록 네트워크를 통해 접근 가능한 캐시 저장소
- 로컬 캐시와 달리, 서버간 데이터 일관성을 유지하고 확장성과 안정성이 뛰어남

- 로컬 캐시 문제점
  + 서버마다 캐시가 서로 독립적으로 존재
  + 한 서버에서 데이터가 갱신되어도 다른 서버의 캐시는 오래된 데이터를 유지
  + 서버가 재시작되면 캐시 데이터가 초기화되어, DB 부하가 일시적으로 급증
 
- 다중 서버 환경에서 데이터 일관성 문제 발생
  + 서버간 캐시 공유 구조 필요
 
- 분산 캐시는 모든 서버가 공통 캐시 저장소에 접근하여 데이터를 읽고 저장

- 분산 캐시는 단순히 캐시 공유를 넘어 확장성과 고가용성 제공
  - 확장성
    + 서버 수가 증가하더라도 캐시 데이터는 중앙에서 관리되므로, 부하를 균등하게 분산할 수 있음
   
  - 고가용성
    + 마스터-슬레이브 구조를 통해 장애 시에도 서비스 중단 없이 운영
    + 장애 감지와 자동 복구를 지원
    + 안정적 서비스 운영의 핵심 인프라
   
## Redis
- 데이터를 메모리에 저장하는 초고속 인메모리 데이터 저장소
  + 필요할 때 디스크에 백업
 
- 싱글 스레드 기반의 고성능 구조
  - 논블로킹 I/O 모델을 통해 초당 수십만 건의 요청을 처리할 수 있음
  - 한 스레드만 실행되므로 락 불필요 (경쟁 조건 없음)
  - Context Switching 없음
 
- 데이터 구조 요약

| 타입 | 설명 | 주요 활용 사례 |
|-|-|-|
| String | 기본 데이터 타입(문자열, 숫자 등) | 세션 토큰, 사용자 이름 |
| List | 순서가 있는 데이터 목록 | 메시지 큐, 최근 검색 기록 |
| Set | 중복 없는 집합 | 좋아요 사용자 목록, 태그 관리 |
| Sorted Set(ZSet) | 점수 기반 정렬 집합 | 랭킹 시스템, 점수 집계 |
| Hash | key-value 쌍의 객체형 데이터 | 사용자 프로필, JSON 구조 |
| bitmap/hyperLogLog | 비트 연산 또는 통계 집계용 | 방문자 수, 클릭 수 |

- Redis 영속성
  - RDB (Redis Database Snapshot)
    + 일정 주기로 전체 데이터를 스냅샷 형태로 디스크에 저장
    + ```
      save 900 1 # 900초 내 1회 이상 변경 시 저장
      save 60 1000 # 1분 내 1000건 이상 변경 시 저장
      ```
    + 복원 속도 빠름, 백업 용이
    + 주기적 저장이라 최근 변경 데이터 손실 가능
  - AOF(Append Only File)
    + 모든 쓰기 명령을 순차적으로 파일에 기록
    + 장애 발생 시 명령을 다시 실행하여 복구
    + ```
      appendonly yes
      appendfsync everysec
      ```
    + 데이터 손실 최소화
    + 파일 크기가 커지고 복구 시간이 김
   
  - 혼합 전략
  - 두 방식을 병행하여, 속도와 안전성의 균형을 맞출 수 있음
  - 빠른 백업 및 복원 + 안정적인 실시간 보존 / 고속성과 안정성을 동시에 확보
 
- 클러스터링
  - 클러스터 구조
    + Master Node : 실제 데이터 저장 및 요청 처리
    + Replica Node : Master 복제본 유지, 장애 시 승격 (Failover)
    + Slot : 데이터를 해시 기반으로 분산 저장
    + 클러스터는 자도응로 데이터 샤딩을 수행하여 부하를 분산
   
  - Sentinel 기반 고가용성
    + Sentinel은 Redis 서버의 상태를 모니터링하고, 장애 발생 시 자동으로 복구
   
## 분산 캐시 패턴
- Look-Aside Cache Pattern (Lazy Loading)
  - 애플리케이션이 먼저 캐시를 조회하고, 없을 경우 직접 조회하여 캐시에 적재하는 방식
- Write-Through Cache Pattern (Synchronous Write)
  - 애플리케이션이 데이터를 저장할 때 캐시와 DB에 동시에 반영하는 방식
  - 장점 : 항상 캐시와 DB가 일관된 상태 유지
  - 단점 : 쓰기 작업이 느려질 수 있음
  - 적합한 경우 : 데이터 무결성이 중요한 환경
 
- Write-Behind Cache Pattern ( Asynchronous Write )
  - 캐시에 먼저 쓰고, 일정 시간이 지난 후 DB에 반영
  - 장점 : 빠른 응답, 쓰기 집중 시스템에 유리
  - 단점 : 장애 시 DB 반영 누락 가능성
  - 적합한 경우 : 로그성 데이터, 통계 데이터 등 일시적 지연 허용 가능 환경
  - 이벤트 방식을 자주 이용
 
## 분산 캐시 고려사항
- 네트워크 지연과 오버헤드
  - 캐시 접근 속도는 네트워크 품질에 크게 영향을 받음
  - 최적화
    + 로컬 캐시
    + Connection Pool 재사용
    + 파이프라이닝
    + 압축
   
- 데이터 일관성 관리
  - 캐시 데이터와 원본 데이터의 불일치 문제
  - 해결 전략
    + TTL 설정
    + Write-Through
    + CacheAside
    + Pub/Sub 동기화
   
- 장애 대응 전략
  - 장애 유형
    + 캐시 서버 다운
    + 네트워크 단절
    + Redis 재시작
   
  - 복구 전략
    + Replicatino
    + Persistence(AOF/RDB)
    + Sentinel 모니터링
    + Cluster 모드
   
- 보안 고려사항
  - 주요 보안 항목
    + 인증 : requirepass 옵션을 통해 비밀번호 설정
    + TLS 암호화 : 전송 중 데이터 보호
    + 접근 제어 : 특정 IP만 접속 가능하도록 방화벽 또는 보안 그룹 설정
    + 데이터 마스킹 : 민감 데이터는 캐시 전 단계에서 암호화 후 저장
