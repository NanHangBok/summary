# DAY_91

## 목차
- [세션 기반 인증의 한계](#세션-기반-인증의-한계)
- [토큰 기반](#토큰-기반)

---

## 세션 기반 인증의 한계
- 인증 정보를 서버에 저장하기 때문에 로드 밸런스를 통한 확장된 서버에서 인증 정보를 일관성 있게 관리하기 어려움
  - 세션이 저장된 저장소가 분산됨
  - 공유 저장소를 사용하면 부하가 생김
  - 요청 서버를 고정하면 분산이 제대로 되지 않을 수 있음
 
## 토큰 기반
- 사용자가 로그인에 성공하면 서버가 세션을 저장하지 않고, 대신 토큰을 발급하여 클라이언트가 이를 보관하고 요청마다 서버에 전달하는 방식
- 서버가 사용자 상태를 저장하지 않으므로 Stateless 아키텍처를 따름

#### stateless
- 토큰 기반 인증은 Stateless(무상태) 아키텍처의 핵심.
- 서버는 클라이언트의 인증 사태를 저장하지 않고, 오직 요청에 담긴 토큰만으로 사용자를 식별

- 특징
  - 서버 상태 저장 없음
  - 인증 정보 위치 클라이언트가 보관
  - 각 요청마다 토큰을 검증하여 처리
 
- 장점
  - 서버 확장 시 세션 공유 문제 해결 (서버 간 세션 동기화 불필요)
  - 부하 분산이 용이
  - 서버 리소스 절약 (세션 저장 공간 불필요)

| 항목        | 세션 기반 인증         | 토큰 기반 인증        |
|------------|---------------------|-------------------|
| 서버 상태 저장 | 세션 저장소 필요       | 저장하지 않음         |
| 확장성       | 세션 공유 필요         | 서버간 동기화 불필요   |
| 부하 분산     | sticky session 필요 | 자유로운 부하 분산 가능 |

#### 토큰의 자체 포함성
- 토큰은 보통 JWT 형태로 발급
- JWT는 자체적으로 사용자 정보와 권한 등을 포함

- 구조
  - Header : 토큰 타입(JWT)과 서명 알고리즘 정보
  - Payload : 사용자 정보와 만료 시간
  - Signature : 서버 비밀키를 이용한 서명 값 (위조 방지)
 
- 토큰만 있으면 서버는 추가 조회 없이 사용자 정보를 확인할 수 있음
- 세션 저장소를 따로 운영할 필요가 없음

#### 서버 부하 분산과 확장성 향상
- 서버 확장성
  - 서버는 토큰만 검증하면 되므로, 사용자 수가 늘어나도 세션 저장소 부담이 없음
  - 새로운 서버를 추가하더라도 세션 동기화 과정이 필요하지 않음
 
- 부하 분산
  - 모든 서버가 동일한 방식으로 토큰 검증을 수행할 수 있음
  - 특정 서버에 사용자를 고정시키는 sticky session이 필요하지 않음

#### 토큰 기반 인증이 적합한 상황
- RESTful API 설계 서버
- 마이크로서비스 아키텍처
- SPA(Single Page Application)
- 모바일 애플리케이션

- 토큰은 보통 HTTP 헤더에 실어 전송
- 마이크로서비스 환경에서는 중앙 인증 서버를 두고 토큰 발급과 검증을 일원화하는 구조를 많이 사용

- 정리

| 상황         | 세션 기반 한계               | 토큰 기반 장점            |
|-------------|--------------------------|------------------------|
| RESTful API | 상태저장 필요 → 서버 확장성 저하 | Stateless 요청 처리 가능   |
| 마이크로서비스  | 중앙 세션 공유 어려움          | 각 서비스 독립적으로 토큰 검증 |
| SPA         | CSRF 방어 필요, 쿠키 관리 복잡 | 토큰을 직접 관리하여 단순화    |
| 모바일 앱     | 네트워크 환경 따라 세션 불안정    | 토큰 저장 후 재사용으로 안정적 |


## JWT
- JSON 객체를 이용하여 안전하게 정보를 주고받기 위한 토큰 형식
- 주로 인증과 권한 부여를 위해 사용됨
- JSON 기반 : 사람이 읽기 쉽고 기계가 처리하기 쉬운 JSO 형식으로 작성됨
- URL-safe : URL에 포함될 수 있도록 Base64URL 방식으로 인코딩 됨
- 자가 포함 : 토큰 자체에 필요한 정보를 담고 있어 별도의 조회가 필요하지 않음
- ![%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3%20(28)](https://github.com/user-attachments/assets/1a1d3dd7-7d28-45ba-a3f9-d6ab7b2f39b2)
  - 웹 서비스에서 로그인 성공 시 JWT를 발급하고, 이후 모든 요청에 토큰을 포함시켜 사용자 인증을 처리
- 모바일 앱은 세션 유지가 어려운 환경이므로, JWT를 활용하여 Stateless 인증을 구현하는 경우가 많음
- MSA 구조에서 서로 다른 서버 간 API 호출 시 JWT를 사용하여 보안을 강화할 수 있음

#### 구조
- Header
  - 메타데이터를 담고 있음
  - 서명 알고리즘 종류
  - 토큰의 타입 명시
- payload
  - 사용자의 인증 정보가 담겨 있음
  - 어떤 정보에 접근 가능한지에 대한 권한을 담을 수도
  - 사용자의 이름 등 필요한 데이터를 담을 수 있음
  - 민감한 정보는 담지 않는 것이 좋음
  - 클레임 종류
    - Registered Claims
    - Public Claims
    - Private Claims
   
- Singature
  - JWT의 무결성을 보장하는 부분
  - 토큰을 위조되지 않았음을 검증하기 위한 서명이 포함
 
#### 인코딩
- Base64URL
  - Base64 인코딩을 URL 환경에서도 안전하게 사용 될 수 있도록 일부 문자 대체
  - + -> -
  - / -> _
  - = -> 제거

#### 서명
- JWT 인증과 데이터 무결성을 보장하기 위해 서명을 포함
- header와 payload를 조합하여 생성됨
- 목적
  - 변조 방지
  - 인증 보장
 
- 무결성과 정합성
  - 무결성 : 데이터가 변조되지 않고 원본 상태를 유지하는 성질
  - 정합성 : 여러 데이터 간 논리적 일관성이 유지되는 성질

- 대칭키 비대칭키 서명
  - 대칭키 : 동일한 비밀키로 서명 미 검증 ( 서명과 검증에 같은 비밀키를 사용 )
  - 비대칭키 : 개인키로 서명, 공개키로 검증
 
## 암호화
- 데이터를 제 3자가 이해할 수 없는 형태로 변환하여 정보의 기밀성을 보호하는 기술
- 대칭키 암호화
  - 같은 키로 암호화와 복호화를 수행하는 방식
  - 암호화와 복호화 모두 같은 키를 사용하기 때문에 키가 노출되면 전체 암호문이 해독됨
- 비대칭키 암호화
  - 서로 다른 두 개의 키를 사용하는 방식
  - 공개키 : 외부에 공개되어 누구나 사용할 수 있음 (암호화 또는 서명 검증)
  - 비밀키 : 본인만 알고 있음 (복호화 또는 서명 생성)
