# DAY 102

## 목차
- [실시간 통신](#실시간-통신)
- [실시간 통신 패러다임](#실시간-통신-패러다임)
- [실시간 통신 기술](#실시간-통신-기술)
- [WebSocket](#websocket)
- [SSE](#sse)

---

## 실시간 통신
- 실시간 통신의 필요성
  - 변화가 발생하는 즉시 사용자 화면에 반영되도록 해야함
  - ex
    - 메시지 앱
    - 협업 문서
    - 주식/가상자산 차트
    - 게임/IoT 대시보드
  - 서버 쪽 변화가 사용자에게 곧바로 전파되어야 가치가 생김
 
- 전통적 HTTP 요청-응답 모델의 한계
  - HTTP는 태생적으로 **비연결성**과 **무상태성** 특성을 가짐
    - 확장성과 단순성을 제공하지만, 서버가 주도적으로 클라이언트에게 변화를 알리기 어려움
   
  - 비연결성
    - 요청->응답이 끝나면 연결(전송 경로,소켓)이 끊긴 것으로 간주
    - 서버는 연결을 붙잡고 있지 않으므로, 서버->클라이언트 방향의 즉시 통지(Push)가 기본적으로 불가능함
    - 결과: 변화가 생겨도 사용자는 다시 요청(pull) 해야만 새로운 정보를 받음
   
  - 무상태성
    - 각 요청은 서로 독립적이며, 서버는 이전 요청의 문맥(세션 상태)를 보존하지 않음
    - 매 요청마다 인증 정보, 컨텍스트, 필터링 파라미터 등을 반복 전송해야 함
    - 결과: 대화 지속성이 필요한 실시간 상호작용(채팅 타이핑 상태, 협업 커서 위치 등)에 비효율이 큼
   
  - 주기적 갱신(Pooling)으로 때우는 경우 생기는 문제
    - 불필요한 반복
    - 이벤트 손실
    - N:1 부하 집중
   
  - 네트워크, 플랫폼 레벨에서의 구조적 한계
    - 프록시/캐시의 개입 : 중간 프록시가 응답을 캐싱하면 최신성이 깨질 수 있음
    - 모바일 네트워크 가변성 : 라디오 절전, 핸드오버로 인해 RTT가 요동하고, 짧은 주기의 폴링은 배터리를 크게 소모시킴
   
  - 사용자 경험,비용 측면의 영향
    - 느린 체감 : 즉시성 기대에 어긋나 신뢰를 낮춤
    - 운영 비용 증가 : 의미 없는 요청 폭증으로 인프라 비용,로그 볼륨이 증가
   
  - 충분한 경우
    - 데이터 변경 빈도가 낮고, 수 초, 수 분 단위 지연이 허용되는 정적/준정적 화면
    - 사용자 규모가 작고, 상호작용성이 낮은 내부 도구,어드민 화면
    - 규제,보안상 양방향 연결 유지가 곤란한 환경에서 제한적 조회 중심 서비스
   
#### 실시간 통신 구조
- 단계
  - 연결 요청 : 클라이언트가 서버에 실시간 연결을 요청
  - 연결 유지 : 연결이 유지되는 동안 양방향 통신이 가능
  - 이벤트 발생 : 서버나 클라이언트에서 데이터 변경이 발생
  - 데이터 전송 : 즉시 반대쪽으로 데이터가 전송
  - 브로드캐스트 : 서버가 모든 관련 클라이언트에게 동일한 데이터를 전송
 
## 실시간 통신 패러다임
#### 폴링
- 가장 단순한 형태의 실시간 통신 방식.
- 클라이언트가 일정한 주기로 서버에 요청을 보내는 구조
- 장점
  - 구현이 매우 간단함
  - 방화벽, 프록시 등 네트워크 제약이 거의 영향을 받지 않음
- 단점
  - 변경이 없더라도 계속 요청을 보내므로 불필요한 트래픽 증가가 발생
  - 실시간성이 떨어짐
  - 서버에 불필요한 부하가 누적됨
 
#### 롱 폴링
- 폴링의 단점을 개선한 방식
  - 요청을 보낸 후 서버가 새로운 데이터가 생길 때까지 응답을 지연시킨 뒤 한 번에 전달하는 구조
- 장점
  - 기존 폴링보다 서버 부하를 줄이고, 실시간성에 근접한 응답이 가능
  - 별도의 프로토콜을 사용하지 않아 HTTP 인프라를 그대로 활용
- 단점
  - 클라이언트와 서버 간 지속적인 연결 유지로 인한 리소스 점유가 큼
  - 서버는 요청을 오랫동안 유지해야 하므로 스레드나 커넥션 풀이 쉽게 고갈될 수 있음
  - 네트워크 오류, 타임아웃 등의 예외 상황을 별도로 처리해야 함

---

- *단방향, 양방향*
| 구분 | 단방향 통신 | 양방향 통신 |
|-|-|-|
| 기본 프로토콜 | HTTP | WebSocket 등 |
| 데이터 흐름 | 요청-> 응답 | 양쪽에서 자유롭게 송수신 |
| 연결 유지 | 요청 시마다 새 연결 | 지속 연결 유지 |
| 사용 사례 | 폴링, 롱 폴링, SSE | WebSocket 기반 채팅, 알림, 게임 |


## 실시간 통신 기술
- WebSocket
  - 클라이언트와 서버가 하나의 지속적인 연결을 유지하며 양방향 메시지를 주고받는 프로토콜
- Server-Sent Events(SSE)
  - 서버에서 클라이언트로 단방향 스트림
  - 서버가 클라이언트로 단방향 데이터를 스트리밍하는 방식
  - 서버가 클라이언트에게 주기적으로 데이터를 보내야 할 때 적합
 
- Webhook
  - 서버 간에 이벤트 발생을 알리기 위해 HTTP POST 요청을 보내는 방식
  - 클라이언트 통신이 아니라 서버 간 알림 구조
 
## WebSocket
- 연결을 지속하면서, 클라이언트와 서버가 자유롭게 데이터를 주고받을 수 있는 통신 채널

#### TCP 기반 전이중(Full-Duplex) 통신
- TCP 위에서 동작하는 응용 계층 프로토콜
  - TCP는 연결 지향형 프로토콜, 세션이 유지되는 동안 양방향 통신이 가능

#### HTTP 핸드셰이크
- Upgrade 요청 흐름
  - WebSocket 연결은 일반적인 HTTP 요청으로 시작
  - 이후 클라이언트가 "Upgrade:websocket" 헤더를 포함해 요청을 보내면 서버는 101 SwitchingProtocols 응답으로 연결을 승격
- 보안이 필요한 환경에서는 WSS 프로토콜을 사용
- HTTPS와 동일하게 TLS(SSL) 계층 위에서 동작하여 데이터 암호화와 무결성을 보장
- 프레임 구조
  - 데이터를 프레임 단위로 전송
  - FIN : 1 bit : 메시지의 마지막 프레임 여부
  - Opcode : 4bit : 프레임의 타입( 텍스트, 바이너리, Ping 등)
  - Mask : 1bit : 마스킹 여부
  - Payload Length : 7~64bit : 전송 데이터 길이
  - payload Data : 가변 : 실제 데이터

- **WebSocket은 연결이 끊기면 자동 복구되지 않으므로, 재연결 로직을 클라이언트에 구현해야 함**
- **서버에서 너무 많은 클라이언트 세션을 유지할 경우 메모리 누수 및 커넥션 풀 한계 문제가 발생할 수 있음**

#### 보안 및 성능 최적화
- HTTP 요청을 업그레이드 하는 과정을 거치며 연결을 설정
  - 이 과정에서 기존의 인증 정보를 함께 전달할 수 있음
- STOMP를 사용하는 경우, 클라이언트가 CONNECT 프레임을 보낼 때 인증 정보를 헤더에 포함할 수도 있음
  - 세션기반에 사용 못함 (쿠키를 못 불러옴)
 
- 연결 풀링과 자원 관리
  - 연결이 장시간 유지되므로, 각 세션이 서버 메모리와 스레드 리소스를 점유
  - 클라이언트 수가 많아질수록 부하가 증가하므로 연결 수 관리 및 자원 해체가 필수
  - 세션 관리 전략
    - 세션 타임아웃 : 일정 시간동안 메시지 송수신이 없으면 연결 종료
    - 연결 수 제한 : IP 또는 사용자 당 최대 연결 수 제한
    - 유휴 세션 정리 : heartbeat 미응답 세션 제거

## SSE
- 서버가 클라이언트로 데이터를 지속적으로 전송하기 위한 HTTP 기반의 단방향 스트리밍 기술
  - 한 번의 요청으로 지속적인 응답 스트림을 열어두고, 서버가 새로운 데이터가 생길 때마다 클라이언트에 이벤트를 푸시
 
#### SSE 프로토콜 구조
- 이벤트 스트림 포맷
  - SSE는 HTTP 응답을 끊지 않고, 텍스트 기반 이벤트 스트림을 지속적으로 전송.
  - 응답의 Content-Type은 반드시 text/event-stream 이어야 함
 
- 자동 재연결 메커니즘
  - 네트워크 오류나 서버 문제로 연결이 끊어져도 자동으로 재연결을 시도
    - 클라이언트는 Last-Event-ID 헤더를 자동으로 전송
    - 서버는 해당 ID 이후의 이벤트부터 다시 전송
    - 서버는 retry: 필드로 재연결 간격을 제안할 수도 있음
