# DAY_101

## 대용량 트래픽 관리 정리

### 동기 비동기
- **동기(Synchronous)**
  - 요청한 작업이 끝날 때까지 다음 작업이 대기
  - ex: 순차적 코드 실행
 
- **비동기(Asynchronous)**
  - 요청한 작업의 완료 여부와 관계없이 다음 작업을 수행
  - ex: 병렬적으로 여러 작업 수행
 
### 블로킹 논 블로킹
- **블로킹**
  - 호출한 함수가 작업을 끝낼 때까지 제어권을 반환하지 않음
  - 작업 온료 후 제어권 반혼
 
- **논블로킹**
  - 호출 즉시 제어권을 반환하며, 완료 여부는 나중에 확인
  - 즉시 제어권 반환
 
### 동기/비동기 + 블로킹/논블로킹 조합
| 구분           | 제어 흐름                               | 스레드 상태           | 대표 예시                 |
|---------------|---------------------------------------|-------------------|-------------------------|
| 동기 + 블로킹    | 작업 완료까지 기다림                       | 제어권 반환 X        | Thread.sleep()          |
| 동기 + 논블로킹   | 결과를 반복 확인 (Polling)                | 제어권 즉시 반환      | NIO Channel + while 루프 |
| 비동기 + 블로킹   | 별도 스레드에서 실행하지만, 호출자는 결과 기다림  | Future.get()      |                         |
| 비동기 + 논블로킹 | 별도 스레드에서 실행되고 결과는 콜백으로 전달     | CompletableFuture |                         |

### 스레드 동작 구조
- MainThread -> 비동기 작업 요청 -> WorkerThread
- WorkThread -> 즉시 제어권 반환 -> MainThread
- MainThread -> 다른작업 수행 -> MainThread
- WorkThread -> 작업 완료 통보(콜백) -> MainThread

### 성능 관점에서의 차이
| 비교 항목   | 동기 처리                 | 비동기 처리                        |
|----------|-------------------------|---------------------------------|
| CPU 활용률 | 낮음(대기 시간 발생)         | 높음 (대기 시간 최소화)              |
| 응답 시간   | 느림                     | 빠름                             |
| 구현 난이도 | 쉬움                      | 상대적으로 복잡(콜백/스레드 관리 필요)   |
| 적합한 환경 | 단순 요청, 처리량이 적은 시스템 | 대규모 트래픽, 외부 API 호출, I/O 작업 |

### 스레드 기반 비동기 처리
- Thread를 이용한 비동기 처리
  - Thraed 클래스를 사용
  - 직접 스레드를 생성하지 않고, 스레드 풀을 사용
 
- ExecutorService를 이용한 스레드 풀 관리
  - **스레드 풀**
    - 미리 생성해둔 일정 수의 스레드를 재활용하는 구조
    - 매번 스레드를 새로 생성하지 않아도 되므로, 자원을 절약하고 안정적인 성능을 유지할 수 있음
  - 스레드 생성, 관리, 종료를 자동으로 처리 함
 
- CompletableFuture를 이용한 고수준 비동기 처리
  - 콜백 기반으로 비동기 작업 연결
  - 콜백을 이용해 논블로킹 체이닝 가능
  - 에러 핸들링 지원
  - 여러 비동기 작업을 합성 가능

- CPU 작업과 I/O 작업을 분리하여 다른 스레드 풀을 사용하는 것이 좋음

### 이벤트 루프 기반 비동기
- 이벤트 루프는 단일 스레드 환경에서도 수천 개의 요청을 효율적으로 처리할 수 있는 비동기 모델
- 주로 I/O 중심 애플리케이션(네트워크, 파일, DB 요청 등)에서 매우 효과적
- 대표적으로 Node.js, Spring WebFlux, Project Reactor 등이 이 모델을 사용

#### 이벤트 루프 구성 요소
- 이벤트 루프 : 요청의 등록, 실행, 완료를 관리하는 메인 루프 스레드
- 이벤트 큐 : 처리해야 할 요청(작업)을 저장하는 큐
- 콜백 : 작업 완료 후 실행될 코드 블록
- Non-Blocking I/O API : OS 수준에서 제공되는 비동기 처리 기능

#### 이벤트 루프 장점과 한계
- 장점 :
  - 스레드 생성/관리 오버헤드 없음
  - 메모리 효율 높음
  - 동시 요청 처리량 우수
 
- 한계 :
  - CPU 연산이 많은 작업에는 부적합
  - 콜백 중첩 발생 가능
 
### 메시지 기반 비동기 처리
- 서로 다른 시스템이나 프로세스 간에 메시지를 교환하며 비동기적으로 작업을 처리하는 방식
- 메시지 큐가 중간에서 데이터를 안전하게 전달하고 일시적으로 보관

- 메시지 큐의 구조와 동작
  - 메시지 큐는 요청과 응답이 동시에 처리되지 않아도 되는 비동기 구조를 제공
  - 발신자는 메시지를 보낸 뒤 기다릴 필요 없이 바로 다음 작업을 수행할 수 있으며, 수신자는 나중에 메시지를 꺼내 처리
 
- 구성 요소
  - Producer : 메시지를 생성하여 큐로 전송 / 발신 후 대기하지 않음
  - Message Queue : 메시지를 임시 저장하고 전달 보장 / 네트워크 지연이나 서버 다운에도 안정적
  - Consumer : 큐에 쌓인 메시지를 순서대로 소비 / 병렬로 여러 Consumer를 둘 수 있음
 
- 메시지 큐의 특징
  - 비동기성 : 요청과 응답이 동시에 일어나지 않아도 됨
  - 내결함성 : Consumer 장애 시에도 메시지가 손실되지 않음
  - 확장성 : 여러 Consumer가 병럴로 메시지를 처리 가능
  - 순서 보장 : FIFO 기반으로 메시지 순서 유지 가능
  - 버퍼링 : 과도한 요청 폭주 시 임시 저장소 역할 수행
 
### 발행 구독 패턴
- 하나의 메시지를 여러 구독자에게 동시에 전달할 수 있는 구조
- 생산자는 단 한 번 메시지를 발행하지만, 이를 구독한 모든 소비자가 동일하게 받을 수 있음

#### 기존 메시지 큐 , pub-sub 패턴 비교
| 항목 | 메시지 큐 | 발행-구독 |
|-|-|-|
| 메시지 전달 대상 | 한 Consumer만 수신 | 여러 Subscriber에게 전달 가능 |
| 사용 예시 | 주문 처리, 이메일 발송 등 | 실시간 알림, 스트리밍, 브로드캐스트 |
| 데이터 보존 | 처리 후 삭제 됨 | 일정 기간 Topic에 저장 가능 |
| 메시지 분류 | 큐 단위 | 토픽 단위 |
| 시스템 구조 | Point-to-Point | Broadcast(Fan-out) |

#### 적용
- 서비스 유형
  - 실시간 알림
  - 이벤트 로깅
  - 주문 시스템
  - 스트리밍 데이터
 
### 비동기 처리가 필요한 경우
- 동기 방식의 한계
  - I/O 요청이 끝나기 전까지 서버 스레드는 블로킹 상태
  - 대량 요청이 들어오면 스레드 수 증가 -> 메모리/CPU 낭비 -> 처리 지연
 
- 비동기 방식의 이점
  - 비동기는 요청을 보내고 응답을 기다리지 않은 채 다음 작업을 처리
  - 요청 수만큼 스레드가 필요 -> 스레드는 생성/관리 비용이 커서, 일정 수준을 넘으면 스레드 컨텍스트 스위칭 비용이 폭증
  - 스레드 수를 늘리지 않아도 대기 중인 요청을 교차 처리 -> CPU는 항상 일하는 상태를 유지하여 처리량이 증가
 
### 스레드
- 스레드는 프로그램 내에서 독립적으로 실행되는 흐름을 의미
- 하나의 프로그램(프로세스) 안에서 여러 스레드가 동시에 작업을 수행할 수 있음
- 각 스레드는 메모리를 공유하며, 병렬적으로 작업을 수행할 수 있음

- 프로세스와 스레드
| 항목 | 프로세스 | 스레드 |
|-|-|-|
| 실행 단위 | 프로글매 전체 실행 | 프로그램 내 일부 실행 흐름 |
| 메모리 공간 | 독립적 메모리 영역 | 프로세스 내 메모리 공유 |
| 통신 방식 | IPC(Inter Process Communication) 필요 | 메모리 공유로 빠름 |
| 생성 비용 | 높음 (OS에서 자원 할당 필요) | 낮음 (프로세스 내 생성) |
| 예시 | 크롬 브라우저, IntelliJ, Discord | 탭별 실행, UI/네트워크 처리 스레드 |

- 메인 스레드
  - 가장 먼저 실행되는 메서드는 main 메서드
  - 메인 스레드가 main 메서드를 실행시켜 줌
  - 메인 스레드는 main 메서드의 코드를 처음부터 끝까지 차례대로 실행시키며, 코드의 끝을 만나거나 return문을 만나면 실행 종료
  - 자바 프로그램이 실행될 때 자동으로 생성되는 스레드이며, 프로그램의 시작점이 됨
 
- 작업 스레드
  - 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이를 멀티 스레드 프로세스라 함
  - 여러 개의 스레드를 가진다는 것은 여러 스레드가 동시에 작업을 수행할 수 잇음을 의미 -> 멀티 스레딩
  - 작업 스레드는 백그라운드나 별도의 계산, 네트워크 통신, 파일 입출력 등을 처리하기 위해 사용
 
- 멀티스레드의 장점과 위험성
  - 장점 :
    - CPU의 멀티코어를 효율적으로 활용할 수 있음
    - 동시에 여러 작업을 수행할 수 잇음
    - 사용자 경험을 개선할 수 있음
   
  - 위험성 :
    - 자원을 동시에 접근할 경우 경쟁 상태가 발생할 수 있음
    - 잘못된 동기화로 인해 데드락이 발생할 수 있음
    - 디버깅과 테스트가 어려워 짐
   
### 스레드 생성과 실행
- 작업 스레드가 수행할 코드를 작성하고, 작업 스레드를 생성하여 실행시키는 것을 의미
- run()이라는 메서드 내에 스레드가 처리할 작업을 작성해야 함
  - run() 메서드는 Runnable 인터페이스와 Thread 클래스에 정의되어 있음
  - 1. Runnable 인터페이스를 구현한 객체에서 run()을 구현하여 스레드를 생성하고 실행하는 방법
    2. Thread 클래스를 상속받은 하위 클래스에서 run()을 구현하여 스레드를 생성하고 실행하는 방법
  - run()은 단순히 작업 내용만 정의하며, start()를 호출해야 JVM이 새로운 스레드를 생성하여 병렬로 실행
 
- Runnable 인터페이스
  - 스레드를 정의하기 위한 함수형 인터페이스
 
- Thread 클래스
  - 자바에서 스레드를 직접 표현하는 클래스
 
#### Thread 실행 제어
- start()
  - 스레드를 실행하려면 반드시 start() 메서드를 호출해야 함
- sleep()
  - 현재 실행 중인 스레드를 일정 시간 동안 멈추게 함
- join()
  - 특정 스레드가 끝날 때까지 다른 스레드를 대기 시킴
- interrupt()
  - 스레드를 강제 종료하지 않고, 단지 중단 요청 신호를 보냄
  - 스레드 내부에서 isInterrupted()나 InterruptedException을 통해 이를 감지하고 직접 종료를 제어
 
### 멀티 스레드 위험성
- 멀티스레드는 동시에 여러 작업을 처리할 수 있지만, 공유 자원을 동시에 접근할 때 심각한 문제가 발생할 수 잇음
- 이러한 문제는 대부분 Race Condition (경쟁 상태)에서 비롯됨
- 작업이 원자적으로 수행되지 않으면 발생 -> 읽기와 쓰기가 분리되어 수행되는 비원자적 연산에서 자주 발생

### 동기화 방법
- 여러 스레드가 동시에 동일한 객체나 변수에 접근할 수 있음 -> Race Condition이 발생하여 데이터가 손상될 수 있음
- 이를 방지하기 위해 동기화를 적용
- 동기화란 여러 스레드가 하나의 공유 자원을 동시에 접근하지 못하도록 임계 구역을 설정하는 방법
- 한 스레드가 자원을 점유하면 다른 스레드는 대기 상태로 전환되어 순차적으로 접근

#### 임계 영역과 락
- 임계 영역은 오로지 하나의 스레드만 코드를 실행할 수 있는 코드 영역을 의미
- 락은 임계 영역을 포함하고 있는 객체에 접근할 수 있는 권한을 의미
- 특정 코드 구간을 임계 영역을 설정할 때는 synchronized라는 키워드를 사용

#### 스레드 안전 컬렉션의 필요성
- 멀티스레드 환경에서는 여러 스레드가 동시에 같은 컬렉션 객체에 접근할 수 있음
- ex: ArrayList에 여러 스레드가 동시에 add() 작업을 수행하면 내부 배열 인덱스가 꼬여서 IndexOutOfBoundsException이 발생할 수 있음

- ConcurrentHashMap
  - HashMap을 개선하여, 여러 스레드가 동시에 데이터를 읽고 쓰더라도 안전하게 동작하도록 설계된 구조
  - 내부적으로 데이터를 여러 개의 구역으로 분하랗여 관리
  - 각 구역은 별도의 락을 가지고 있어서, 여러 스레드가 동시에 서로 다른 구역을 수정할 수 있음
  - 덕분에 성능과 스레드 안전성을 모두 보장
 
- BlockingQueue
  - 스레드 간 데이터 교환을 위해 설계된 큐 구조
  - put()은 큐가 가득 차면 대기하고, take()는 큐가 비어 있으면 대기
  - 주요 구현체
    - ArrayBlockingQueue
    - LinkedBlockingQueue
    - PriorityBlockingQueue
    - DelayQueue
   
### 스레드 풀
- 스레드 풀은 미리 생성해둔 스레드 집합에서 작업을 가져와 실행하는 방식
- 매번 새로운 스레드를 만들지 않고 이미 만들어진 스레드를 재사용함으로써 성능을 향상 시킴

- 필요성
  - 스레드 생성/소멸 비용 절감
    - 스레드는 생성할 때마다 메모리 스택 공간과 운영체제의 문맥 등록이 필요
    - 매 요청마다 새 스레드를 생성하면 성능이 급격히 저하됨
    - 스레드 풀은 이러한 문제를 해결하기 위해 스레드를 미리 만들어 재사용
   
  - 스레드 개수 제한을 통한 자원 관리
    - 시스템은 한정된 CPU 코어와 메모리를 가지고 있으므로, 스레드가 많을수록 문맥 전환 비용이 커짐
    - 최대 스레드 개수를 제한하여 시스템 자원을 보호
    - 이렇게 하면 CPU가 처리 가능한 양을 초과하는 스레드가 생기지 않아 안정적인 실행이 가능
   
- 작업 큐
  - 스레드 풀에서 작업 요청은 먼저 작업 큐에 저장됨
  - 스레드가 비면 큐에서 하나씩 작업을 꺼내 실행함
 
- 단일 스레드는 모든 작업이 순차적으로 실행되므로 처리 속도가 매우 느림

### Executor
- 스레드를 직접 생성하고 관리하는 복잡성을 줄이기 위해 추상화한 인터페이스 Executor 제공
- ExecutorService 같은 구현체를 활용
  - why?
    - 스레드 생성 비용 문제
    - 자원 관리의 어려움
    - 비동기 결과 및 예외 처리 부족

| 구분 | 단순 Executor 직접 구현 | ExecutorService 사용 |
|-|-|-|
| 스레드 생성 비용 | 매번 new Thread()로 생성 -> CPU/메모리 낭비 | 스레드 풀을 사용해 재사용 |
| 자원 관리 | 스레드 종료,예외 처리 직접 관리 필요 | shutdown(), awaitTermination() 등 관리 기능 제공 |
| 결과 처리 | 반환값 관리 불가능 (Runnable만 가능) | Callable, Future로 결과 추적 가능 |

- ExecutorService는 스레드의 생명주기 관리 기능이 추가된 구조
  - 스레드를 종료할 수 있고(shutdown)
  - 결과를 반환받을 수 있으며(Callable / Future)
  - 여러 작업을 동시에 제출하고 관리할 수 있음
 
- Runnable은 결과를 반환하지 않지만, Callable은 작업이 끝난 뒤 결과를 반환할 수 있음
  - 이때 반환값을 비동기적으로 받을 수 있는 객체가 바로 Future
 
- ScheduledExecutorService
  - 작업을 일정 주기로 예약할 수 있음

### 스레드 풀 예외 처리
- Future를 통한 예외 처리
  ```java
  future.get(); // 예외를 던짐 try-catch로 예외 처리
  ```
  - 내부에서 발생한 예외는 ExecutionException으로 감싸져 전달 됨

### Runnable의 한계
- 결과값을 반환할 수 없음
- 예외도 메인 스레드로 전달되지 않음
- 반환값 부재
- 예외처리 불가
- 비동기 제어 어려움

### Callable
- 반환값을 가지며, 예외를 던질 수 있음
- call()
- 단독으로 실행되지 않고 ExecutorService를 통해 실행 됨
- 제네릭을 사용하여 반환 타입을 명확하게 지정

### Future
- 비동기 작업의 결과를 나중에 받을 수 있게 해주는 인터페이스
- Callable이나 Runnable의 실행 결과를 나중에 조회하거나 제어할 수 있도록 함
- 주요 메서드
  - get() : 작업이 완료될 때까지 블로킹하여 결과를 반환
  - get(long timeout, TimeUnit unit) : 지정된 시간 동안만 대기하고, 초과 시 TimeoutException 발생
  - cancel(boolean myaInterruptIfRunning) : 작업을 취소함
  - isDone() : 작업이 완료되었는지 여부를 반환
  - isCancelled() : 작업이 취소되었는지 여부를 반환


### ExecutorService와 Future
- ExecutorService.submit() 비동기 작업을 스레드 풀에 제출하고, 즉시 Future 객체를 반환
  - 여러 개의 Callable을 리스트 형태로 만들어 제출하면, 각 작업마다 별도의 Future를 받을 수 있음
- invokeAll()
  - 모든 작업 완료 대기
  - 모든 작업이 끝날 때까지 기다림
  - 일괄처리에 유용
- invokeAny()
  - 가장 먼저 끝난 작업의 결과만 받기
  - 여러 작업 중 가장 빨리 끝난 하나의 결과만 반환
  - 나머지 작업은 자동으로 취소
  - 빠른 응답이 필요한 서비스(여러 서버 중 가장 빨리 응답한 결과 사용)에 적합

### Future 한계
- get() 메서드는 결과가 준비될 때까지 현재 스레드를 멈추게 함
- 이로 인해 비동기 실행의 장점이 반감되는 문제가 발생할 수 있음
- 블로킹의 실질적 문제
  - CPU 낭비
  - 응답 지연
  - 확장성 저하
 
- 콜백 메커니즘의 부재
  - Future는 단순히 결과를 보관하는 객체이므로, 작업이 완료되었을 때 자동으로 후속 동작(콜백)을 실행할 수 없음
 
- 연쇄 작업의 어려움
  - Future는 반환값을 직접 받아서 다음 작업에 넘기는 방식 외에는 연결 실행이 불가능
  - 각 단계가 끝날 때마다 직접 get()으로 결과를 확인해야 함
 
### CompletableFuture
- 기존 Future의 문제
  - 블로킹 문제
  - 콜백 부재
  - 연쇄 작업 불가
  - 비동기 처럼 보이지만 실질적으로는 동기에 가까운 구조

- 비동기 단계를 연결할 수 있는 구조 제공
  - 비동기 작업을 조합하고 연결할 수 있는 실행 파이프라인

- 람다 표현식과 메서드 체이닝을 결합하여 비동기 코드를 마치 데이터 스트림처럼 자연스럽게 표현할 수 잇음

#### CompletionStage
- 여러 비동기 작업을 단계로 표현하고, 이들을 연결할 수 있도록 설계된 인터페이스
- 즉 작업이 끝나면 다음 작업을 실행하라는 개념을 코드 수준에서 지원

- 핵심 메서드 분류
  - 결과 변환 thenApply() : 이전 결과를 변환하여 반환
  - 결과 소비 thenAccept() : 결과를 받아 처리하고 반환 없음
  - 후속 실행 thenRun() : 결과와 관계없이 후속 동작 수행
  - 조합 실행 thenCombine(), thenCompose() : 여러 작업 결합 및 순차 연결

- 핵심 장점 요약
  - 비동기 자동 연결 CompletionStage 기반의 체이닝 지원
  - 함수형 구성 : 람다와 체이닝으로 간결한 코드 작성 가능
  - 콜백 내장 : 작업 완료 후 자동 후속 처리 지원
  - 병렬 처리 지원 : 여러 비동기 작업을 결합하여 병렬 수행 가능
  - 명시적 예외 처리 : handle(), exceptionally() 등 예외 흐름 관리 가능
 
### CompletableFuture 생성 방식
| 메서드 | 반환 타입 | 설명 |
|-|-|-|
| runAsync(Runnable) | CompletableFuture<Void> | 반환값이 없는 비동기 작업 실행 |
| supplyAsync(Supplier<T>) | CompletableFuture<T> | 반환값이 있는 비동기 작업 실행 |
| completedFuture(T value) | CompletableFuture<T> | 이미 완료된 Future를 생성 |

- CompletableFuture.join()
  - 비동기 작업이 끝날 때까지 현재 스레드를 대기(Blocking)시킴
  - 작업이 끝나면 결과를 반환하거나, 예외가 발생했을 경우 RuntimeException으로 래피앟여 던짐
  - 즉, 결과를 기다리되 Checked Exception을 던지지 않기 때문에 테스트 코드나 간단한 데모 코드에서 매우 자주 사용 됨.
 
- join(), get()
| 구분 | get() | join() |
|-|-|-|
| 예외 처리 | InterruptedException, ExecutionException(checked) | CompletionException(Unchecked) |
| 코드 작성 난이도 | 예외 처리 필요(try-catch 필수) | 예외 처리 선택적 (try-catch 없어도 됨) |
| 사용 용도 | 실무 서비스 코드 | 테스트, 간단한 예제 |
| 반환 시점 | Future 완료 시까지 대기 | Future 완료 시까지 대기 |
| 예외 래핑 | ExecutionException | CompletionException |

#### ForkJoinPool.commonPool()
- 자바가 기본적으로 제공하는 공용 스레드 풀
- supplyAsync()를 실행할 때 별도의 Executor를 지정하지 않으면 자동으로 이 공용 풀에서 스레드가 할당되어 작업을 수행하게 됨

### 기본 작업 처리 메서드

