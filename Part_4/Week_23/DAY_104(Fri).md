# DAY_104

## 목차
- [프로토콜 선택](#프로토콜-선택)
- [HTTP 프로토콜](#http-프로토콜)
- [HTTP 메시지](#http-메시지)
- [HTTP 연결 관리](#http-연결-관리)
- [HTTPS](#https)
- [암호학 기초](#암호화-기초)
- [SSL/TLS](#ssl/tls)
- [HTTPS 통신](#https-통신)
- [인증서](#인증서)
---

## 프로토콜 선택
- 어떤 방식으로 통신할지를 결정하는 역할
  - 선택의 따라 서비스의 속도, 안정성, 확장성에 직접적인 영향을 미침
 
| 기존 항목 | TCP 사용 시 | UDP 사용 시 |
|-|-|-|
| 신뢰성 | 데이터 손실이 허용되지 않는 경우 | 일부 데이터 손실이 허용되는 경우 |
| 속도 | 빠르지 않아도 무관함 | 지연 시간이 짧아야 함 |
| 데이터 순서 | 순서가 보장되어야 함 | 순서 보장이 필요 없음 |
| 예시 | 결제 시스템, 이메일, 파일 업로드 | 스트리밍, 게임, 음성 통화 |

- 프로토콜 선택은 서비스 품질을 결정 짓는다.
  - 실시간성, 안정성, 비용 중 어떤 요소를 우선시할지 고려해야 함
 
## HTTP 프로토콜
- HTML 같은 문서를 전송하기 위한 application layer 프로토콜
- HTTP는 웹 상에서 문서를 전송하기 위한 통신 규약
- HTTP의 특징 : 무상태성
- HTTP Headers : 요청을 지정하거나, 메시지에 포함된 본문을 설명하는 헤더의 집합
- 기본 포트는 80, HTTPS는 443번을 사용
- TCP/IP 위에서 동작

- HTTP/0.9 - 최초의 HTTP
  - 가장 단순한 형태의 요청/응답 모델
  - 요청 메서드는 GET만 존재
  - 헤더 개념이 없음
  - 응답은 단순히 HTML 문서의 본문만 전달
- HTTP/1.0 - 웹의 대중화
  - 오늘날의 웹 구조의 기초를 다짐
  - 헤더 도입 : 요청과 응답에 메타데이터 포함
  - 다양한 메서드 : GET, POST, HEAD 지원
  - 콘텐츠 타입 : **Content-Type을 통해 HTML 외에도 이미지, 동영상 전송 가능**
  - 상태 코드 : 응답의 성공/실패를 구분하는 코드 등장 (ex : 200 OK, 404 Not Found...)
 
- HTTP/1.1 표준화와 효율화
  - 오늘날까지도 가장 널리 사용되는 버전
  - 주요 특징
    - 지속 연결 : Connection: keep-alive를 통해 한 TCP 연결로 여러 요청 처리
    - 파이프라이닝 : 여러 요청을 동시에 보낼 수 있음
    - Host 헤더 필수화 : 하나의 서버가 여러 도메인 처리 가능 (가상 호스팅)
    - 캐싱 : 불필요한 데이터 전송 감소
  - 대규모 웹사이트 운영이 가능해짐
  - CDN, 캐시 서버, 리버스 프록시 개념이 본격 도입됨
 
- HTTP/2 - 멀티플렉싱의 등장
  - 기존의 텍스트 기반 프로토콜을 바이너리 프레임 구조로 변경
  - 멀티플렉싱 : 하나의 TCP 연결에서 여러 요청을 병렬 처리
  - 헤더 압축 : 중복되는 헤더 정보를 효율적으로 압축
  - 서버 푸시 : 클라이언트 요청 없이 미리 리소스 전송 가능
  - 장점
    - 페이지 로드 속도 개선
    - 네트워크 효율성 향상
    - 대규모 SPA, API 서버에 적합
   
- HTTP/3 - QUIC 기반의 차세대 프로토콜
  - TCP 대신 UDP 기반의 QUIC 프로토콜을 사용
  - QUIC는 google이 개발한 전송 계층 프로토콜
    - 기존 TCP 단점을 극복하고 지연 시간을 최소화하며 보안과 안정성을 동시에 보장하기 위해 설계 됨
   
  - QUIC  핵심 특징
    - UDP 기반 : TCP보다 빠른 연결 수립 가능
    - 0-RTT 연결 : 이전 연결 정보를 재활용해 즉시 데이터 전송 가능
    - 헤드 오브 라인 블로킹 제거 : 한 요청의 지연이 다른 요청에 영향을 주지 않음
    - 암호화 기본 내장 : TLS 1.3이 프로토콜에 통합되어 보안 수준 향상
    - 패킷 손실 복구 속도 향상 : 손실된 패킷만 재전송, 전체 세션 지연 감소
   
#### 웹의 성장
- 정적 웹에서 동적 웹으로
  - 초기의 웹은 HTML 문서를 보여주는 정적 웹
  - 점차 사용자 입력을 처리하고, 데이터베이스와 연동하는 동적 웹으로 발전
 
- HTTP 확장성
  - 단순한 문서 전송을 넘어 데이터, 이미지, 파일, JSON, 영상 등 모든형태의 콘텐츠를 전송할 수 있도록 발전
  - 또한, HTTP는 다양한 인증, 보안, 캐싱 매커니즘을 통해 현대 웹의 기본 인프라가 되었음
 
#### REST 아키텍처와 HTTP
- REST는 HTTP 프로토콜의 철학을 극대화한 아키텍처 스타일
- HTTP가 제공하는 표준 메서드(GET, POST, PUT, DELETE)와 리소스 기반 설계를 활용
- REST 핵심 원칙
  - 리소스 중심의 URI 설계
  - HTTP 표준 메서드 활용
  - 무상태성
  - 계층적 구조
 
| REST 개념 | HTTP 기능 | 설명 |
|-|-|-|
| 리소스 식별 | URI | /users/1, /articles/5 등으로 리소스 표현 |
| 행위 정의 | HTTP 메서드 | GET, POST, PUT, DELETE 등 |
| 표현 전달 | Content-Type | JSON, XML 등 다양한 형식으로 데이터 전송 |
| 무상태 통신 | Stateless | 각 요청이 독립적으로 처리 됨 |

- 장점
  - 표준 기반으로 상호운용성이 높음
  - 클라이언트와 서버의 역할이 명확히 분리 됨
  - HTTP 프로토콜 위에서 동작하므로 추가 학습 부담이 적음

## HTTP 메시지
- HTTP 통신은 요청과 응답 두 가지 메시지 형태로 이루어 짐
- HTTP 메시지는 기본적으로 텍스트 기반으로 구성
  - 사람이 직접 읽고 이해할 수 있음
 
- 요청 메시지 구조
  - ```
    [start line] -> 메서드, 경로, 프로토콜 버전
    [Headers] -> 요청에 대한 부가 정보
    [본문(body)] -> 클라이언트가 서버로 전송하는 데이터  (post, put 등에서 사용)
    ```
  - start line
    - 수행할 작업이나 방식을 설명하는 메서드
    - 요청 대상 또는 프로토콜, 포트, 도메인의 절대 경로는 요청 컨텍스트에 작성
    - HTTP 버전에 따라 HTTP message의 구조가 달라짐
      - 따라서 start line에 HTTP 버전을 함께 입력
     
  - Headers
    - 헤더이름, 콜론, 값 을 입력
    - 여러 종류의 헤더가 있음
      - General headers : 메시지 전체에 적용되는 헤더, body를 통해 전송되는 데이터와 관련 없음
      - Request headers : fetch를 통해 가져올 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더
      - Representation headers : 이전에는 Entity headers로 불림, body에 담김 리소스의 정보를 포함하는 헤더
     
  - body
    - HTTP messages 구조의 마지막
    - 모든 요청에 body가 필요하지 않음
    - 종류
      - single-resource bodies(단일-리소스 본문) : 헤더 두 개로 정의된 단일 파일
      - multiple-resource bodies(다중-리소스 본문) : 여러 파트로 구성된 본문에서는 각 파트마다 다른 정보를 지님
     
- 응답 메시지 구조
  - ```
    [status line] -> 프로토콜 버전, 상태 코드, 상태 멧지ㅣ
    [headers] -> 응다벵 대한 메타데이터
    [본문(body)] -> 실제 응답 데이터 (HTML, JSON 등)
    ```
  - status line
    - 응답의 첫줄은 status line이라 부름.
    - 현재 프로토콜의 버전
    - 상태 코드
    - 상태 텍스트
   
  - headers
    - 요청 헤더와 동일한 구조

  - body
    - 모든 응답에 body 가 필요하지는 않음
   
#### 주요 헤더 필드
- 요청과 응답 양쪽에서 메타데이터를 전달하기 위한 필드
- 요청 헤더 예시

| 헤더명 | 설명 |
|-|-|
| Host | 요청 대상 서버 도메인 |
| User-Agent | 클라이언트 정보 |
| Accept | 클라이언트가 처리 가능한 데이터 타입 |
| Content-Type | 요청 본문 데이터 형식 |
| Authorization | 인증 정보 전달 |

- 응답 헤더 예시

| 헤더명 | 설명 |
|-|-|
| Content-Type | 응답 본문의 데이터 형식 |
| Content-Length | 본문 길이 |
| Set-Cookie | 쿠키 설정 |
| Cache-Control | 캐시 정책 설정 |
| Location | 리다이렉트 URL |

#### HTTP 상태 코드
| 구분 | 범위 | 의미 |
| 1xx | 정보 응답 | 요청을 수신했으며 계속 진행 중 |
| 2xx | 성공 응답 | 요청이 정상적으로 처리 됨 |
| 3xx | 리다이렉션 | 추가 조치 필요 |
| 4xx | 클라이언트 오류 | 잘못된 요청 |
| 5xx | 서버 오류 | 서버 내부 문제 발생 |

## HTTP 연결 관리
- HTTP/1.0 시절에는 요청 1건당 TCP 연결 1회릀용하는 비효율적인 구조를 가지고 있었음
  - 비지속 연결
    - 각 요청마다 TCP 3-way handshake를 반복 수행
    - TCP 연결 생성/종료 비용이 매우 큼
    - 여러 리소스를 요청하는 웹 페이지에서는 과도한 연결 오버헤드가 발생
   
  - 지속 연결
    - HTTP/1.1 부터 기본저그올 connection: keep-alive 헤더를 통해 하나의 TCP 연결을 여러 요청/응답에 재사용
      - 서버는 응답 후에도 TCP 연결을 닫지 않고 일정 시간 유지
      - 클라이언트는 같은 연결을 통해 여러 요청을 연속적으로 전송할 수 있음
      - TCP 연결 생성/ 조욜에 필요한 오버헤드 감소
      - 전송 지연 감소
      - 서버 측 자원이 장시간 점유될 수 있음
      - 너무 많은 연결 유지 시 서버 리소스 부족 현상 발생
     
  - 파이프라이닝
    - HTTP/1.1에서는 요청-응답 순서를 기다리지 않고 여러 요청을 연속적으로 전송할 수 있도록 개선한 방식이 도입됨
    - 작동 방식
      - 클라이언트는 첫 번째 응답을 기다리지 않고  다음 요청을 전송
      - 서버는 순서대로 응답을 반환해야 함
      - 응답 순서는 항상 요청 순서와 동일해야 하며, 하나의 요청이 지연되면 이후 모든 응답도 지연 됨
     
    - 문제점
      - 첫번째 요청이 느리면 뒤의 모든 응답이 지연되는 구조적 한계
     
    - 대안
      - HTTP/2 에서는 파이프라이닝의 문제를 해결하기 위해 멀티플렉싱 기술 도입
      - 하나의 TCP 연결 위에서 여러 요청과 응답을 동시에 교차 전송할 수 있는 기능
     
## HTTP 보안적 한계
- HTTP는 평문으로 데이터를 전송하기 떄문에, 네트워크 상에서 패킷을 도청하거나 위조할 수 있음
- 평문 통신의 문제
  - 도청 : 네트워크 중간자가 요청/응답 내용을 볼 수 있음
  - 위조 : 중간자가 응답 내용을 변조할 수 있음
  - 피싱 : 사용자가 위조된 서버와 통신하게 될 수 있음
 
- 해결 방법
  - HTTPS 등장, HTTPS는 TLS 프로토콜을 사용해 데이터를 암호화
  - 데이터를 암호화하여 도청 및 변조를 방지
  - 서버 인증서를 통해 통신 대상이 신뢰할 수 있는 서버인지 검증

 ## HTTPS
 - HTTP 통신에 암호화 계층 (TLS/SSL)을 추가하여 데이터를 안전하게 주고받기 위한 프로토콜
   - 기존의 HTTP는 평문으로 데이터를 전송하지만, HTTPS는 이를 암호화하여 도청,위조,스푸핑을 방지
  
 - HTTP 보안 취약점
   - 평문 통신 : 요청과 응답이 암호화되지 않음 -> 도청 가능
   - 무결성 부재 : 데이터가 중간에 변조되어도 탐지 불가 -> 위조 가능
   - 인증 부재 : 서버의 신원을 검증하지 않음 -> 피싱 위험
  
 - 중간자 공격
   - 공격자가 클라이언트와 서버 사이의 통신을 가로채거나 조작하는 공격 기법
   - 실제 피해 예시
     - 데이터 도청 : 암호화되지 않은 트래픽을 엿봄 -> 로그인 정보 탈취
     - 데이터 변조 : 응답 HTML을 변조해 악성 코드 삽입 -> 광고,피싱페이지 주입
     - 서버 위조 : 가짜 인증서를 발급받아 위조 서버 운영 -> 피싱 사이트 접근 유도
    
 - HTTPS가 보호하는 세 가지 보안속성
   - 기밀성 : 데이터를 암호화하여 외부에서 내용을 읽을 수 없게 함 : TLS 암호화
   - 무결성 : 데이터가 전송 중변조되지 않았음을 보장 : 메시지 인증 코드 (MAC)
   - 인증 : 통신 상대방(서버)이 신뢰할 수 있는 대상임을 검증 : 인증서 기반 검증
  
- HTTPS의 동작 개념
  - 클라이언트가 서버에 HTTPS 요청을 보냄
  - 서버는 자신의 인증서를 클라이언트에게 보냄
  - 브라우저는 인증서를 검증해 서버의 신뢰성을 확인
  - 검증이 완료되면 양측은 암호화된 세션 키를 생성
  - 이후 통신은 모두 암호화된 상태로 이루어짐
 
- HTTPS로 전환된 이유
  - 사용자 보호
  - SEO 강화
  - 브라우저 정책
  - 공공기관 의무화
 
- HTTPS가 제공하는 사용자 신뢰도 향상
  - 주소창 표시
  - 검색 엔진 최적화(SEO)
  - 데이터 보호
  - 결제 및 인증
 
## 암호학 기초
- 목적
  - 기밀성 : 게이터를암호화하여 외부에서 내용을 볼 수 없게 함
  - 무결성 : 데이터가 변조되지 않았음을 증명
  - 인증 : 통신 상대의 신원을 보장
  - 부인 방지 : 송신자가 자신이 보낸 행위를 나중에 부정할 수 없도록 보장
    - 내가 보낸적 없다 라고 주장할 수 없게 만듦
   
- 대칭키 암호화
  - 하나의 동일한 키로 데이터를 암호화와 복호화 하는 방식
  - 송신자와 수신자가 같은 비밀키를 공유
  - 키가 유출되면 누구든 데이터를 복호화 할 수 있어 보안상 위험이 있음
   
  - 특징
    - 속도 : 빠름 (단순 연산)
    - 키 개수 : 1개(양쪽 동일)
    - 단점 : 키 전달이 어렵고 노출 위험 있음
    - 대표 알고리즘 : AES, DES, Blowfish
 
- 비대칭키 암호화
  - 공개키와 개인키 두 개의 키를 사용하는 방식
    - 공개키는 모두에게 공개할  수 있음
    - 개인키는 오직 소유주만 가지고 있어야 함
  - 누구나 공개키로 암호화 할 수 있지만, 개인키를 가진 사람만 복호화할 수 있음
 
  - 특징
    - 속도 : 느림(복잡한 수학 연산)
    - 키 개수 : 2개(공개키, 개인키)
    - 장점 : 키를 노출하지 않아도 안전하게 교환 가능
    - 대표 알고리즘 : RSA, DSA, ECC
   
- 해시 함수와 메시지 무결성
  - 해시는 데이터를 고정된 길이의 요약값으로 변환하는 함수
    - 입력이 조금만 바뀌어도 완전히 다른 결과를 생성
    - *순수 함수 : 동일한 입력에 동일한 출력*
   
  - 특징
    - 입력 크기 : 제한 없음
    - 출력 크기 : 고정 길이
    - 복호화 가능 여부 : 불가능(단방향 함수)
    - 대표 알고리즘 : SHA-256, SHA-512, MD5
   
- 디지털 서명
  - 비대칭키 암호화와 해시를 결합하여 데이터의 신뢰성과 발신자 인증을 보장하는 기술
  - 동작 원리
    - 송신자는 데이터를 해시로 요약
    - 그 해시값을 개인키로 암호화해 디지털 서명을 만듦
    - 수신자는 송신자의 공개키로 서명을 복호화하여 원래의 해시 값을 얻음
    - 받은 데이터의 해시값과 비교해 같으면 변조되지 않았음을 확인
   
  - 특징 요약
    - 사용 알고리즘 : 비대칭키
    - 검증 대상 : 데이터 무결성, 발신자 신원
    - 대표 활용 : HTTPS 인증서, 소프트웨어 서명, 블록체인 트랜잭션
   
## SSL/TLS
- SSL
  - HTTPS는 단순히 HTTP+ 보안계층 의 결합으로 이해할 수 있음
    - 이 보안 계층을 처음 제안한 것이 바로 SSL
  - 이후 인터넷 표준화 단체가 내놓은 개선한 버전이 TLS
 
- TLS
  - 계층 구조
    - 전송 계층과 응용 계층 사이에서 동작
    - TCP 위에 TLS가 존재하고, 그 위에 HTTP가 올라가는 구조
  - 암호화 + 인증 + 무결성 담당 / TCP가 제공하지 못하는 보안성 보완
 
  - TLS 프로토콜
    - Record Protocol
      - TLS의 핵심 데이터 전송 계층
      - 데이터 조각화 : 전송 데이터를 일정 크기로 나눔
      - 압축 : 선택적으로 데이터 압축
      - 암호화 : 세션 키를 이용해 암호화 수행
      - 메시지 인증 : 데이터 위조 여부 검증
     
    - Handshake Protocol
      - TLS 연결이 시작될 때 서버와 클라이언트가 서로를 신뢰하고 세션 키를 합의하는 과정 담당
        - ClientHello : 클라이언트가 지원하는 암호화 알고리즘과 랜덤값을 서버에 전달
        - ServerHello : 서버가 사용할 암호화 방식 선택 및 인증서 전달
        - Key Exchange : 세션 키 교환
        - Finished : 핸드셰이크 완료, 안전한 통신 시작
       
    - Change Cipher Spec Protocol
      - 지금부터 전송되는 데이터는 암호화된 상태로 전송하겠다는 신호를 주고 받는것
        - 이 프로토콜은 TLS 1.3 부터는 내부적으로 통합되어 별도로 존재하지 않음
       
    - Alert Protocol
      - 통신 중 문제가 발생했을 때 에러나 경고를 전달하는 역할
     
## HTTPS 통신
- 과정
  - TLS 핸드셰이크(비대칭키)
  - 세션 키 생성 및 교환
  - 암호화된 HTTP 데이터 송수신(대칭키:세션키)
 
- HTTPS의 보안은 '데이터 암호화' 자체보다, 안전한 키 교환 과정에 있음. 그 핵심이 바로 TLS Handshake

- TLS 핸드셰이크
  - 클라이언트와 서버가 처음 연결될 떄, 암호화 방식과 키를 협상하는 절차
  - ClientHello
    - 지원 암호화 알고리즘
    - 랜덤 데이터 (Client Random)
   
  - ServerHello + Certificate
    - 서버 인증서 (공개키 포함)
    - 랜덤 데이터 (Server Random)
   
  - Pre-Master Secret 생성 및 암호화 전달
    - 서버 공개키로 암호화 됨
   
  - Pre-Master Secret 복호화
    - 자신의 개인키로 복호화
   
  - Finished
 
  - 과정
    - clientRandom 서버로 보내줌 (ex:A)
    - ServerRandom 클라이언트로 보내줌(ex:B) + 공개키 보내줌
    - Client가 공개키로 임의의 값 암호화 (Pre-Master Secret) -> 서버로 보내줌
    - Server가 개인키로 Pre-Master Secret 복호화 -> Pre-Master 값  확인
    - Client와 Server는 각자 Pre-Mastser + Client Random + Server Random을 계산해서 가지고 통신함 (세션키)
   
## 인증서
- 서버가 진짜 신뢰할 수 있는 대상임을 증명하는 전자 서명된 문서
  - 브라우저는 서버로부터 인증서를 받아 이를 검증함으로써 이 사이트가 위조되지 않았음을 확인
 
- 인증서 체인
  - 루트 CA는 최상위 신뢰 기관으로, 운영체제나 브라우저에 미리 내장되어 있음
  - 루트 CA가 중간 CA에 서명함으로써 신뢰 위임
  - 중간 CA가 실제 서비스(서버)에 대한 인증서를 발급
  - 클라이언트(브라우저)는 서버 인증서의 체인을 따라 올라가며 검증 수행
 
- 인증서 종류
  - 도메인 검증 수준에 따른 분류
    - DV (Domain Validated) : 검증수준 낮음 / 도메인 소유만 확인, 자동 발급 가능
    - OV (Organization Validated) : 검증수준 중간 / 실제 기업 정보 검증 포함, 상용 서비스에 주로 사용
    - EV (Extended Validation) : 검증수준 높음 / 법적 실체,주소 등까지 검증, 은행,금융 서비스에 사용
   
  - 도메인 패턴에 따른 구분
    - 단일 도메인 인증서 : 한 개의 도메인만 커버
    - 와일드카드 인증서 : 하위 도메인 전체를 커버
    - SAN 인증서 : 여러 개의 도메인, 서브도메인을 한 번에 포함 가능
      - 마이크로서비스 아키텍처나 다중 서브도메인 환경에서 효율적
      - 관리 복잡도가 높아 주기적 갱신 자동화가 필요
     
- 인증서 발급 기관(CA)
  - 역할
    - 신원 확인 : 신청자의 도메인/조직 소유 여부 검증
    - 인증서 발급 : 검증 후 공개키 기반의 인증서 생성
    - 인증서 갱신 : 만료 전 재발급 지원
    - 인증서 폐기 : 유출/오류 발생 시 CRL, OCSP로 폐기 처리
   
  - CA가 유출되면 하위 인증서 전체가 무효화될 수 있으므로 CA는 엄격한 보안 환경에서 운영 됨
 
# 
