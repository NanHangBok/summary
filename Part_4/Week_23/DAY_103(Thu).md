# DAY 103

## 목차
- [실시간 알림 아키텍처](#시스템-알림-아키텍처)
- [서드파티 API 의존성](#서드파티-api-의존성)
- [타임아웃](#타임아웃)
- [서킷 브레이커](#서킷-브레이커)
- [GraphQL](#graphql)
  - [GraphQL 스키마](#graphql-스키마)
  - [GraphQL 쿼리](#graphql-쿼리)
- [프로토콜](#프로토콜)
- [OSI 7계층](#osi-7계층)
- [TCP/IP 4계층](#tcp/ip-4계층)
- [데이터 캡슐화와 역캡슐화](#데이터-캡슐화와-역캡슐화)
- [인터넷 핵심 프로토콜](#인터넷-핵심-프로토콜)
  - [IP](#ip)
  - [TCP](#tcp)
  - [UDP](#udp)
  - [DNS](#dns)
---

## 실시간 알림 아키텍처
- 필요성
  - 현대 웹 애플리케이션은 사용자에게 즉각적인 피드백과 알림을 제공해야 함
  - 전통적인 요청-응답 구조로는 사용자의 요청이 없으면 서버가 알림을 전달할 수 없기 때문에, 서버에서 클라이언트로 즉시 메시지를 전송할 수 있는 구조가 필요
 
- 단일 서버 구조
  - 모든 SSE 연결이 한 서버 인스턴스에 유지
  - 구조가 단순하고 구현이 쉬움
  - 서버 장애 시 모든 연결이 끊어짐
  - 세션 복원이 불가능
 
- 다중 서버(클러스터) 구조
  - 부하 분산을 위해 여러 서버 인스턴스르 사용
  - 각 서버는 개별 EmitterRegistry를 가짐
  - 메시지 브로커를 통해 모든 서버가 알림 이벤트를 동기화
  - 어떤 서버로 연결된 클라이언트든 동일한 알림을 수신할 수 있음
  - 확장성 확보
    - Redis Pub/Sub, Kafka 등을 사용하여 여러 서버 간 알림 동기화 가능
    - 클라이언트 연결은 스티키 세션 또는 토큰 재연결로 관리

- 확장 가능한 알림 아키텍처 설계
  - 주요 컴포넌트 역할 구분
    - EmitterRegistry : 연결 세션 관리 / 세션 수가 많을 경우 ConcurrentHashMap 사용
    - NotificationService : 비동기 이벤트 전송 / ThreadPoolExecutor를 통한 전송 분리
    - MessageBroker : 다중 서버 간 이벤트 중계 / Redis Pub/Sub 또는 Kafka 사용
    - Client : SSE 수신 및 UI 반영 / 자동 재연결 및 상태 표시 구현
   
- 재연결과 장애 복구 전략
  - 자동 재연결 메커니즘
    - 브라우저의 EventSource 객체는 SSE 연결이 끊기면 자동으로 재연결을 시도
    - 서버가 retry: n 이벤트를 전송하면 클라이언트 재시도 주기를 제어 가능
     
  - 서버 측 복구 전략
    - 서버 재시작 : 기존 세션 만료 후 클라이언트 재연결 유도
    - Redis 장애 : 메시지를 큐에 임시 저장 후 재전송
    - 네트워크 단절 : 하트비트 미수신 시 세션 제거 후 재연결 허용
     
- 성능 최적화
  - 연결 수가 수천 개 이 상이면 Thread 수 증가 -> Non-blocking I/O 기반 전송 고려
  - SseEmitter의 send()는 Blocking I/O -> 별도 ThreadPool로 분리 필요
 
- 보안 강화
  - 클라이언트 인증 : JWT 기반 ClientId 검증
  - HTTPS 필수 (SSE도 TLS 위에서 동작)
  - 서버 과부하 방지를 위한 큐 용량 제한 및 백프레셔 도입
 
- 유지보수 포인트
  - 하트비트 주기 모니터링
  - Redis Pub/Sub 메시지 지연 분석
  - 클라이언트 자동 복구 로직 테스트
 
## 서드파티 API 의존성
- 서드파티 API 의존성 관리의 중요성
  - 우리 시스템의 일부 기능을 외부 서비스에 위임하는 방식
  - 아래와 같은 문제가 발생할 수 있음
    - API 제공자 장애로 인한 서비스 중단
    - 응답 지연으로 인한 전체 서비스 지연
    - 요금 제한 초과로 인한 호출 실패
- 외부 API 장애가 미치는 영향
  - 외부 API가 장애를 일으키면 직접적인 장애 전파가 발생할 수 있음
    - 외부 API의 장애가 곧 내부 서버의 장애로 이어질 수 있음
    - 요청이 지연될수록 Thread나 Connection Pool이 소모됨
    - 반복적인 실패는 전체 서비스의 가용성을 저하시킴
   
#### 빠른 실패 원칙
- Fail Fast
  - 실패를 가능한 한 빨리 감지하고 중단함으로써 시스템 전체의 부하 확산을 막는 원칙
  - 실패를 늦게 인지하는 것보다, 빨리 감지하고 복구하는 것이 더 안전하다
 
#### 기본적인 장애 대응 전략
- 격리 : 외부 장애가 내부 전체 서비스로 전파되지 않도록 차단
- 복원 : 장애가 발생해도 빠르게 대체 로직으로 복원
- 완화 : 부하를 줄여 장애의 영향을 최소화

- Fallback 전략
  - 외부 API 실패 시, 사용자에게 기본 메시지를 반환하거나 캐시된 데이터를 제공하는 전략
 
- Graceful Degradation
  - 서비스의 일부 기능만 제한하고, 전체 장애를 막는 전략
    - 결제 API 장애 시, 주문은 접수하되 결제는 "보류 상태"로 저장
    - 번역 API 장애 시, 원문 텍스트만 표시하고 번역은 나중에 수행
   
- Rate Limiting(요청 제한)
  - 외부 API의 호출량이 일정 수준을 넘지 않도록 제어
 
## 타임아웃
- 요청이 일정 시간 안에 응답을 받지 못할 경우, 요청을 강제로 중단하는 메커니즘

- 종류
  - Connection Timeout : 연결 타임아웃
  - Read Timeout : 응답 타임아웃
  - Write Timeout : 요청 본문 타임아웃
 
- 재시도 메커니즘
  - 일시적인 장애가 발생했을 때, 같은 요청을 다시 시도하는 전략
  - 잘못된 재시도는 장애를 악화시킬 수 있음
  - 재시도 시마다 대기 시간을 점점 늘리는 방식을 적용
  - 네트워크 혼잡이 있을 경우, 짧은 간격으로 재시도하면 오히려 부하를 유발
 
## 서킷 브레이커
- 외부 시스템이나 API가 불안정하거나 장애가 발생할 때, 내부 시스템이 그 영향을 최소화하도록 요청을 차단하거나 우회시키ㅡㄴㄴ 패턴
- 상태
  - closed 정상
  - open 차단
  - half-open 일부 통과
 
- 기본 폴백 전략
  - 외부 API 호출 실패 시, 대체 데이터나 로직을 제공하는 복구 전략
  - 유형
    - 캐시 데이터 반환 : 최근 성공 요청 데이터를 캐시로 반환
    - 기본값 : 미리 정의된 기본 응답 제공
    - 대체 서비스 호출 : 다른 API 또는 백업 서버 사용
    - 지연 재처리 큐 등록 : 실패 요청을 나중에 재시도
   
- 서킷  브레이커는 재시도, 타임아웃, 폴백과 함께 설계해야 효과적
- 너무 낮은 실패 임계값은 과도한 차단을 유발
- 폴백 로직은 비즈니스상 안전한 데이터만 반환해야 함

## GraphQL
- 데이터 질의어(Query Language)
- 클라이언트가 필요한 데이터 구조를 직접 정의하여 요청할 수 있음
- 단일 엔드포인트(/graphql)로 다양한 데이터를 요청할 수 있음
- 등장 배경
  - 모바일 시대에 맞춰 데이터 전송 효율성이 중요한 과제가 됨
  - REST API는 각 기능마다 엔드포인트가 달라, 다양한 화면 구성에서 불필요한 데이터까지 전송하는 문제
 
- REST API의 한계
  - 오버페칭
    - 클라이언트가 실제로 필요하지 않은 데이터까지 함께 받아오는 현상
    - 모바일 환경에서는 네트워크 자원을 낭비
    - 클라이언트 렌더링 성능이 저하 됨
   
  - 언더페칭
    - 한 번의 API 호출로 필요한 데이터를 모두 가져오지 못해, 여러 번의 요청을 반복해야 하는 문제
    - 요청 횟수 증가
    - 클라이언트와 서버 간 의존성이 복잡해 짐
    - 네트워크 비용이 증가
   
- GraphQL의 해결 방식
  - 클라이언트 주도 데이터 요청
    - 클라이언트가 필요한 데이터 구조를 선언형으로 정의
    - 필요한 데이터만 선택적으로 수신
    - 오버페칭과 언더페칭 문제를 동시에 해결
    - 서버 변경 없이 클라이언트가 자유롭게 요청 구조를 정의할 수 있음

- 쿼리가 복잡해질수록 서버 부하가 커질 수 있으므로, 쿼리 깊이 제한 설정이 중요

## GraphQL 스키마
- 서버와 클라이언트 간이 계약 역할
- 어떤 데이터를 요청할 수 있고, 어떤 형태로 응답받을지를 명시하는 명세서
  - GraphQL 스키마는 서버가 제공할 수 있는 모든 데이터의 형태를 정의
  - 클라이언트는 이 스키마를 기반으로 요청을 구성
 
- 스키마 정의 언어(SDL)
  - GraphQL의 데이터 구조를 정의하는 언어
 
- 타입 시스템
  - 스칼라 타입 : 단일 값
  - 객체 타입 : 여러 필드로 구성된 구조체
  - 입력 타입 : mutation 입력용 구조체
  - 열거형 타입 : 제한된 상수 집합
  - 인터페이스 / 유니언 : 다형성 데이터 타입
 
- 스칼라 타입
  - 기본 데이터 타입
  - Int : 정수형
  - Float : 실수형
  - String : 문자열
  - Boolean : 참/거짓
  - ID : 고유 식별자
 
- 객체 타입
  - 여러 필드를 포함
  - 중첩 구조 형태로 데이터를 요청할 수 있음
  - ```GraphQL
    type Post {
      id : ID!
      title: String!
      content: String
      author: User!
    }
    ```

- 입력 타입
  - mutation(데이터 변경) 시 클라이언트가 전송하는 입력 값을 구조화하기 위해 사용
  - ```GraphQL
    input UserInput {
      name: String!
      email: String!
      age: Int
    }
    ```

- 열거형 타입
  - 미리 정의된 상수 집합
  - ```GraphQL
    enum Role {
      AMDIN
      USER
      GUEST
    }
    ```

- 쿼리 타입
  - 데이터를 조회하기 위한 루트 타입
  - ```GraphQL
    type Query {
      user(id: ID!): User
      allUsers: [User!]!
    }
    ```
  - Query 타입은 Rest의 GET 요청에 해당
  - [User!]!는 "User 타입의 배열이며, 각 요소의 배열 자체 모두 Null이 될 수 없다"는 의미
 
- 뮤테이션(mutation) 타입
  - 데이터를 추가, 수정, 삭제 하기 위한 루트 타입
  - ```GraphQL
    type Mutation {
      createUser(input: UserInput!): User!
      deleteUser(id: ID!): Boolean!
    }
    ```
 
## GraphQL 쿼리
- 데이터를 조회하기 위한 명령문
- 필요한 필드를 정확히 지정할 수 있음
- ```GraphQL
  query {
    user(id:1) {
      name
      email
    }
  }
  ```
- 응답 데이터 구조를 요청 시점에 정의
- 서버는 클라이언트 요청에 정의된 필드만 반환
  - 오버페칭 문제 해결
 
- 중첩 데이터 요청
  - 중첩을 통해 관련된 데이터를 한 번에 가져올 수 있음
 
- 인자와 변수
  - 인자
    - 각 필드는 함수처럼 인자를 받을 수 있음
    - ```GraphQL
      query {
        posts(limit:2, orderBy: "likes") {
          title
          likes
        }
      }
      ```
   
  - 변수
    - 실제 서비스에서는 요청마다 값이 바뀌므로 변수를 사용
    - ```GraphQL
      query GetUser($userId: ID!) {
        user(id: $userId) {
          name
          email
        }
      }
      ```
    - 요청 본문에 변수를 전달
   
- 별칭과 프래그먼트
  - 별칭
    - 동일한 필드를 여러 번 호출할 수 있음
    - 이때 별칭을 이용하여 구분할 수 있음
    - ```GraphQL
      query {
        topPosts: posts(limit:2) {
          title
        }
        recentPosts: posts(orderBy: "date") {
          title
        }
      }
      ```
  - 프래그먼트
    - 여러 쿼리에서 공통으로 반복되는 필드 그룹을 재사용하기 위한 기능
    - ```GraphQL
      fragment UserFields on User {
        name
        email
        age
      }

      query {
        user(id: 1) {
          ...UserFields
        }
        anotherUser: user(id: 2) {
          ...UserFields
        }
      }
      ```
    - ...은 UserFields 내부 필드를 풀어서 사용한다는 뜻
   
## 프로토콜
- 컴퓨터나 네트워크 장비가 서로 데이터를 주고받을 때 지켜야 하는 통신 규칙의 집합
- 역할
  - 데이터 형식 규정 : 데이터를 어떤 형태로 보낼지 정의
  - 전송 절차 정의 : 언제, 어떤순서로 데이터를 주고받을 지 결정
  - 오류 검출 및 복구 : 데이터 전송 중 오류가 생기면 이를 감지하고 복구
  - 연결 관리 : 통신 연결의 생성과 종료를 관리
  - 흐름 제어 : 송신자와 수신자의 속도 차이를 조절하여 데이터 손실을 방지
- 데이터 전송의 신뢰성, 효율성, 일관성 보장

- 필요성
  - 통신의 표준화
    - 컴퓨터는 제조사, 운영체제, 네트워크 장비가 모두 다를 수 있음
      - 통신이 원활하게 이루어지려면 모든 시스템이 공통으로 이해할 수 있는 규칙이 필요
    - 프로토콜이 없다면, 각 기기가 서로 다른 언어를 사용하면 통신이 불가능
    - 운영체제나 하드웨어를 초월한 공통 규약

- **프로토콜 스택**
  - 프로토콜은 단일 계층으로 동작하지 않음
    - 여러 개의 프로토콜이 계층적으로 쌓여서 함께 작동
    - 이 구조를 프로토콜 스택 또는 프로토콜 계층 구조 라고 함
  - 각 계층은 자신의 역할만 수행하고, 바로 위/아래 계층과만 상호작용 함
  - 계층 구조 장점
    - 유연성 : 한 계층이 바뀌어도 다른 계층은 영향을 거의 받지 않음
    - 표준화 용이 : 계층별로 역할이 명확하므로 국제 표준화가 쉬움
    - 문제 해결 용이 : 통신 장애 발생 시 특정 계층에서 원인을 빠르게 파악할 수 있음
   
## OSI 7계층
- 국제표준화기구에서 제정한 네트워크 통신의 표준 모델
- 데이터 통신 과정을 7개의 계층으로 분리하여 표준화한 구조로 각 계층은 특정한 기능을 수행하며 상하 계층과 협력
- 목적
  - 네트워크 시스템 간의 호환성을 높이기 위해
  - 문제 발생 시, 어느 계층에서 문제가 발생했는지 빠르게 식별할 수 있음
 
| 계층 | 이름 | 주요 역할 | 대표 프로토콜/기술 |
|-|-|-|-|
| 7 | 응용(Application) | 사용자와 직접 상호작용 | HTTP, FTP, SMTP, DNS |
| 6 | 표현(Presentation) | 데이터 형식 변화, 암호화 | JPEG, MPEG, SSL/TLS |
| 5 | 세션(Session) | 통신 세션 관리(연결/종료) | Socket, RPC |
| 4 | 전송(Transport) | 신뢰성 있는 데이터 전송 | TCP, UDP |
| 3 | 네트워크(Network) | 경로 선택, 주소 지정 | IP, ICMP |
| 2 | 데이터링크(Data Link) | 프레임 전송, Mac 주소 관리 | Ethernet, PPP, ARP |
| 1 | 물리(Physical) | 실제 비트 전송 | 케이블, 허브, 전압 신호 |

## TCP/IP 4계층
- 인터넷에서 실제 사용되는 네트워크 통신 구조
| TCP/IP 계층 | OSI 대응 계층 | 주요 역할 | 대표 프로토콜 |
|-|-|-|-|
| 응용 계층 | 응용, 표현, 세션 (7~5계층) | 사용자와 직접 통신 | HTTP, FTP, DNS, SMTP |
| 전송 계층 | 전송 (4계층) | 데이터 신뢰성 보장 | TCP, UDP |
| 인터넷 계층 | 네트워크 (3계층) | IP 주소 관리, 라우팅 | IP, ICMP |
| 네트워크 액세스 계층 | 데이터링크 + 물리 (2~1계층) | 실제 하드웨어 통신 | Ethernet, Wi-Fi |

#### OSI TCP/IP 모델 비교
| 구분 | OSI 7계층 | TCP/IP 4계층 |
|-|-|-|
| 계층 수 | 7 | 4 |
| 표준화 기구 | ISO | DoD(미국 국방성) |
| 이론/실무 구분 | 이론적 모델 | 실무적 모델 |
| 적용 범위 | 모든 네트워크 | 인터넷 중심 |
| 전송 단위 명칭 | 데이터 -> 세그먼트 -> 패킷 -> 프렝임 -> 비트 | 데이터 -> 세그먼트 -> 패킷 -> 프레임 |

## 데이터 캡슐화와 역캡슐화
- 데이터 전송 과정
  - 상위 계층에서 하위 계층으로 내려가며 각 계층이 자신의 헤더를 붙임(캡슐화)
  - 수신 측에서는 반대로 각 계층의 헤더를 제거하며 데이터를 해석(역캡슐화)

| 계층 | 데이터 단위 | 예시 헤더 정보 |
|-|-|-|
| 응용 계층 | Data | HTTP Header(요청 라인, 쿠키 등) |
| 전송 계층 | Segment | TCP Header(포트 번호, 순서 번호) |
| 네트워크 계층 | Packet | IP Header(송신/수신 IP 주소) |
| 데이터링크 계층 | Frame | MAC Header(송신/수신 MAC 주소) |
| 물리 계층 | Bit | 전기 신호/전파 |

## 인터넷 핵심 프로토콜
#### IP
- 네트워크 상에서 데이터를 전송하기 위한 주소 지정과 라우팅(경로 설정)을 담당하는 핵심 프로토콜
- 인터넷에 연결된 모든기기는 고유한 IP 주소를 부여 받음
- 이 주소를 통해 서로 통신
- 데이터를 패킷 단위로 나누어 전송
- 주요 특징
    - 비연결형 : 데이터를 전송하기 전에 연결을 설정하지 않음
    - 비신뢰성 : 패킷이 유실되거나 순서가 바뀔 수 있음
    - 최선형 전달 : 목적지까지 최선을 다해 전송하지만, 성공을 보장하지는 않음
   
- IPv4, IPv6
  - IPv4 : 32비트, 4바이트
  - IPv6 : 128비트, 16바이트
 
- MAC 주소와 ARP 프로토콜
  - MAC 주소 : 네트워크 인터페이스 카드에 부여된 고유한 하드웨어 식별 번호
    - IP 주소만으로는 통신할 수 없으며, 실제 물리적인 네트워크에서 송수신을 수행하려면 MAC 주소가 필요함
    - 이때 ARP이 IP주소로부터 MAC 주소를 찾아주는 역할을 수행
   
- 서브넷 마스크와 네트워크 구분
  - IPv4 주소는 네트워크부와 호스트부로 나뉨
  - IP 주소 : 192.168.1.10
  - 서브넷 마스크 : 255.255.255.0
  - 네트워크 주소 : 192.168.1.0
  - 브로드캐스트 주소 : 192.168.1.255
  - 서브넷 마스크는 어떤 부분이 네트워크 부인지, 어떤 부분이 호스트부인지를 정의
  - 255는 네트워크부를, 0은 호스트부를 의미
  - 사내 네트워크에서 192.168.1.0/24는 254개의 IP(1~254)를 할당할 수 있음
 
#### TCP
- 신뢰성 있는 데이터 전송을 보장하는 연결 지향형 프로토콜
- 데이터가 순서대로, 정확하게 도착하도록 관리하고, 패킷 손실 시 재전송 기능을 수행
- 핵심 기능
  - 연결 지향
  - 순서 보장
  - 손실 복구
  - 흐름 제어 및 혼잡 제어
 
- TCP 3-way handshake 과정
  - 양 끝단의 기기의 신뢰성 있는 데이터 통신을 위해, TCP 방식이 연결을 설정하는 방식
  - SYN
    - receiver에게 sender가 통신을 시작하고 싶다고 알림
  - SYN/ACK
    - Receiver는 받은 요청을 바탕으로 SYN/ACK 신호 세트를 응답
  - ACK
    - sender는 받은 ACK를 receiver에게 전송을 하면서, 신뢰성 있는 연결이 성립되었다는 사실을 sender와 receiver 양쪽에서 알 수 있고, 실제 데이터 전송이 시작
  - 이후 데이터가 전송되고, 종료 시에는 4-way handshake로 연결을 해제
 
- TCP 4-way handshake
  - FIN(sender)
  - ACK(receiver)
  - FIN(receiver)
  - ACK(sender)
 
#### UDP
- TCP와 달리 연결 설정 없이 데이터를 즉시 전송하는 비연결형 프로토콜
- 신뢰성은 낮지만 전송 속도가 매우 빠름
- 사용 이유
  - 애플리케이션의 정교한 제어가 가능
  - 연결설정에 무관
 
#### DNS
- 호스트의 도메인 이름을 IP 주소로 변환하거나 반대의 경우를 수행할 수 있도록 개발된 데이터베이스 시스템

#### 프로토콜 간 협력 구조
- IP는 목적지를 찾고 (주소)
- TCP/UDP는 데이터를 전송하며 (전송 방식)
- DNS는 도메인 이름을 IP로 변환 (이름 해석 시스템)
