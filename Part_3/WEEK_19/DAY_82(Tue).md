# DAY_82

## 목차
- [유저관리](#유저관리)
- [인증](#인증)
- [인증 워크플로우](#인증_워크플로우)
- [인증 상태 유지의 필요성](#인증_상태_유지의_필요성)
- [쿠키](#쿠키)
- [세션](#세션)
- [쿠키와 세션 보안 설정](#쿠키와_세션_보안_설정)
- [기본 인증](#기본_인증)
- [토큰 기반](#토큰_기반)
- [인가](#인가)
- [실제 인가 구현 사례](#실제_인가_구현_사례)
- [세션/토큰 기반 인가](#세션/토큰_기반_인가)
- [OAuth](#oauth)
---

## 유저관리
#### 유저 기능
- 개인별로 식별 가능한 계정을 통해 서비스를 이용할 수 있게 한다.
- 웹 서비스에서 유저 기능의 역할
  - 비회원 : 사이트를 자유롭게 둘러볼 수 있지만, 제한된 기능만 이용할 수 있다.
  - 회원 : 계정을 만들고 로그인해야 하며, 개인화된 서비스(장바구니, 프로필, 주문내역 등)를 이용할 수 있다.
- 유저 식별을 통한 맞춤형 서비스 제공
  - 유저 기능을 통해 서버스는 사용자별로 다른 경험을 제공. (개인화)
    - 넷플릭스 : 로그인하면 본인의 시청 기록과 취향에 맞는 영화가 추천
    - 쿠팡 : 로그인하면 자주 구매한 상품, 배송 주소, 결제 수단이 자동으로 불러와짐.
    - 유튜브 : 로그인 시 개인 구독 목록과 추천 영상이 표시됨.

#### 인증의 개념
이 사용자가 정말 본인이 맞는지 확인하는 과정
- 보통 ID(식별자)와 Password(비밀번호)로 이루어짐
  - ID : 사용자를 구분하기 위한 식별자 (이메일, 아이디, 휴대폰 번호)
  - Password : 사용자가 본인임을 증명하기 위한 비밀 값
- 실제 서비스에서는 비밀번호를 평문으로 저장하지 않고 암호화 기법을 사용
  - sha-256 등의 암호화를 보편적으로 사용하는데 자주 사용하는 비밀번호는 어느정도 유추가 가능
    -> 암호화하고 DB에 저장할때 임의의 문자열을 추가하는데 이것을 `salt` 라고 표현함. ex) 1234+(salt:abc같은 임의의 단어)

- 다양한 인증방식
  - ID + Password
  - 소셜 로그인 / 외부 서비스 계정을 활용
  - 2단계 인증(2FA) / 문자인증, OTP
  - 생체 인증
 
- 인증 인가
  - 인증 : 너는 누구냐 - 사용자가 본인임을 확인하는 과정
  - 인가 : 너에게 무엇을 허용할까? - 특정 자원에 접근할 수 있는 권한을 확인하는 과정
 
## 인증
사용자가 누구인지 확인하는 절차
- 정의와 목적
  - 정의: 사용자의 신원을 증명하는 과정
  - 목적
    - 시스템 접근 제어
    - 개인정보 보호
    - 비인가 사용자 차단
    - 사용자별 맞춤 서비스 제공
- 인증 : 사용자가 본인인지 확인하는 절차
- 인가 : 인증된 사용자가 무엇을 할 수 있는지 결정하는 절차

- 규모가 커지면 인증서버를 따로 두기 때문에 인증 관련 정보를 별도로 관리할 수 있음 (UserCredential)
- 권한 필드를 두어 추후 인가 처리에 활용

#### 이메일과 비밀번호 기반 인증 방식
단순 비교가 아니라 암호화된 값 비교와 추가 인증 관리가 필요합니다.
- 인증 절차 흐름
  - 사용자가 이메일과 비밀번호를 입력
  - 서버는 해당 이메일의 User를 찾습니다
  - 입력한 비밀번호를 해시 처리하여 저장된 해시값과 비교
  - 일치하면 인증 성공, 불일치하면 실패 횟수 증가
  - 실패 횟수가 일정 기준 이상이면 계정을 잠금
 
## 인증 워크플로우
#### 회원가입 워크플로우
- 새로운 사용자가 시스템에 계정을 등록하는 첫 단계
- 워크플로우
  - 사용자
    - 이메일, 비밀번호, 닉네임 입력
  - 서버
    - 입력값 검증 - 이메일 형식, 중복 여부, 비밀번호 정책
  - 검증 단계
    - 검증 성공 / 검증 실패
  - 비밀번호 암호화 / 에러 응답
    - DB 저장
  - 회원가입 완료
- 이메일 인증을 통해 계정 활성화 절차를 두는 것이 안전
- 비밀번호는 반드시 BCrypt, Argon2와 같은 강력한 해시 알고리즘을 사용해야 함.
- 비밀번호 분실 대비 기능(비밀번호 재설정 메일 발송)도 반드시 고려해야 함.

#### 로그인 워크플로우
회원가입된 사용자가 본인임을 증명하는 과정
- 워크플로우
  - 사용자
    - 이메일, 비밀번호 입력
  - 서버
    - 이메일로 사용자 조회
  - DB
    - 사용자 존재 / 사용자 없음
  - 비밀번호 해시 비교 / 로그인 실패
    - 일치 / 불일치
  - 로그인 성공, 세션-토큰 발급 / 로그인 실패
- 로그인 실패 횟수를 기록하여 계정 잠금 정책 적용
- 로그인 성공 시 반드시 세션 또는 토큰을 발급해야 함. -> HTTP의 특징 ) 무상태성, 비연결성 중 무상태성 때문에
- 보안을 위해 로그를 남겨야 하며, 이상 징후(짧은 시간 내 다수 로그인 실패 등)를 탐지하는 것이 중요

## 인증 상태 유지의 필요성
인증 상태 유지는 HTTP 프로토콜의 속성 때문에 필수. \
HTTP는 기본적으로 무상태이며 연결 유지가 보장되지 않는(connection agnostic) 요청-응답 모델을 따름. \
따라서 사용자가 한 번 로그인 했다고 해서 이후 요청에서도 자동으로 신원이 이어지는 것이 아님. \
이 특성 때문에 세션 혹은 토큰 같은 메커니즘으로 "누가 요청했는가"를 매 요청하다 증명해야 함. \

#### HTTP의 속성
- 무상태 : 서버는 각 HTTP 요청을 독립적 사건으로 취급. 이전 요청의 맥락을 자동으로 기억하지 않음
- 연결 재사용과 무관 : HTTP 1.1에서 keep-alive가 있더라도 이는 TCP 소켓 재사용일 뿐 응용 계층의 인증 상태를 보장하지 않음.
  - 로드밸런서가 요청을 다른 서버로 보낼 수도 있고, 연결이 끊겼다가 재연결될 수도 있음.
- 분산 인프라 특성: 실제 서비스는 로드밸런서 다수의 서버, 캐시, 프록시가 개입.
  - 서버 로컬 메모리에만 의존하면 다른 서버로 라우팅되는 순간 인증 상태를 잃어버림.
  - 중앙 저장소(세션 스토어) 또는 클라이언트가 들고 다니는 증표(토큰)가 필요.
- 보안 경계의 일관성 : TLS 종료 시점, 역프록시, API 게이트웨이가 바뀌어도, 요청 그 자체에 신원 증거가 포함되어 있어야 안전함.
  - 즉, 매 요청마다 신원 확인이 가능해야 함.
 
#### 상태 유지 대표 전략
- 세션 기반 방식 (쿠키)
  - 로그인 성공 시 서버가 세션 ID를 생성하고, 이를 쿠기로 클라이언트에 전달함. 이후 요청마다 쿠키로 세션을 찾아 사용자 신원을 복원
  - 구성 요소 : 세션 저장소(메모리, Redis, DB), 쿠키 설정(HttpOnly,Secure,SameSite)
  - 구현이 비교적 단순, 서버가 세션을 제어하므로 즉시 강제 로그아웃 가능 (세션 삭제)
  - 서버 측 상태를 유지하므로 확장 시 저장소 일관성 필요 (공유 저장소 필수)
  - 세션 쿠키 필수 옵션
    - HttpOnly : JS 접근 차단(XSS 완화)
    - Secure : HTTPS에서만 전송
    - SameSite : 크로스 사이트 전송 제어 (Lax, Strict, 필요시 None+Secure)
    - Path : 쿠키가 전송될 경로
    - Domain : 쿠키 적용 도메인 (서비스 도메인으로 제한)
   
  - 확장성 : 다중 서버 환경에서는 스티키 세션 대신 공유 세션 저장소 사용 권장
    - 스티키세션 : 분산 서버 환경에서 세션이 저장되어 있는 서버로만 통신하도록 제한
   
- 토큰 기반 방식 (JWT 등)
  - 로그인 성공 시 서명이 포함된 토큰을 발급. 클라이언트는 이후 요청마다 토큰을 Authorization 헤더로 전송하고, 서버는 서명 검증으로 신원을 확인.
  - 구성 요소 : Access Token(짧은 수명), Refresh Token(긴 수명, 재발급용), 키 관리(비밀키 또는 공개키)
  - 서버가 인증 상태를 저장하지 않아 수평 확장이 쉬움
  - 발급된 토큰은 유효기간 동안 기본적으로 유효함, 강제 만료가 필요하면 블랙리스트나 토큰 버전 필드 등을 도입해야 함.
 
  - JWT 핵심 클레임
    - sub : 주체 ID(유저 식별자)
    - iss : 발급자
    - and : 대상자
    - exp : 만료 시간
    - iat : 발급 시간
    - jti : 토큰 식별자
   
  - 민감정보는 담지 않음.

| 방식 | 설명                             | 장점        | 단점           | 적용 사례      |
|-----|---------------------------------|-----------|---------------|--------------|
| 세션 | 서버 메모리에 인증 정보 저장           | 단순, 안정적 | 서버 부하 증가    | 소규모 웹 서비스 |
| 토큰 | 클라이언트에 토큰 저장 후 매 요청마다 전달 | 확장성 높음  | 토큰 탈취 시 위험 | 모바일, 분산 환경 |


## 쿠키
#### 구조와 속성
- ;으로 구분된 key=value 또는 플래그
- Name=Value 쿠키 이름과 값
- Domain : 쿠키가 전송될 도메인 범위
- Path : 전송 경로 제한
- Expires : 만료 시각(절대)
- Max-Age : 만료까지 남은 시간(초)
- Secure : HTTPS 연결에서만 전송
- HttpOnly : JS 접근 차단
- SameSite : 크로스 사이트 전송 제어
- Priority(브라우저별) 제거 우선순위 힌트

#### 생명주기와 용량 제한
- 세션쿠키 : Expires/Max-Age 미지정. 브라우저 종료 시 삭제.
- 영속 쿠키 : 만료 정보 지정. 지정 시간까지 유지
- 용량 : 브라우저마다 다르나 쿠키 하나 약 4KB, 도메인 당 수십 개 수준이 일반적. 초과 시 오래된 쿠키부터 삭제될 수 있음.

#### 도메인과 경로 매칭 규칙
- Domain 미설정 : 호스트 전용 쿠키. 정확히 일치하는 호스트에서만 전송
- Domain=example.com 설정 : sub.example.com 포함 하위 도메인에도 전송
- Path=/account: /account와 그 하위 경로에만 전송

## 세션
- 클라이언트가 서버에 접속한 순간부터 접속을 끊을 때까지의 연결 상태를 의미
- 세션은 **사용자의 상태 정보를 서버에 저장**해 두고, 이를 세션 ID라는 키로 식별하는 방식
- 특징
  - 서버 중심 관리: 사용자의 로그인 여부, 권한, 장바구니 정보 등을 서버가 직접 보관
  - 클라이언트는 세션 ID만 보관 : 브라우저는 세션 자체가 아니라, 세션을 가리키는 고유 ID를 쿠키에 저장
  - 만료 가능 : 일정 시간 동안 요청이 없으면 세션을 종료(유휴 타임아웃)하거나, 최대 사용 시간을 설정(절대 타임아웃)할 수 있음
  - 보안 의존성 : 세션 ID가 유출되면 사용자 정보가 탈취될 수 있음. 따라서 세션 ID르 안전하게 보호하는 것이 핵심
- 저장 위치 : 서버 (메모리, DB, Redis 등)
- 클라이언트 역할 : 세션 ID를 쿠키에 저장하여 요청마다 전달
- 만교 관리 : TTL, 유휴/절대 타임아웃
- 보안 이슈 : 세션 ID 탈취, 세션 고정 공격

- 세션 생성과 전달
  - 사용자가 로그인
  - 검증에 성공하면 서버는 새로운 세션 객체를 생성하고, 사용자 ID와 관련 정보를 세션 저장소에 저장.
  - 서버는 해당 세션을 식별할 수 있는 세션 ID를 생성
  - 이 세션 ID를 (Set-Cookie 헤더)에 답아 브라우저에 전달
 
#### 세션 기반 인증의 보안 고려사항
- 세션 ID 보안
  - 랜덤성 : 세션 ID는 충분히 긴 난수를 사용해야 함
  - 예측 불가능성 : 단순 증가하는 숫자나 시간 기반 ID는 공격자가 쉽게 추측할 수 있으므로 금지
  - 쿠키 보안 속성
    - Secure : HTTPS 연결에서만 전송.
    - HttpOnly : JavaScript로 쿠키 접근 차단 -> XSS 완화.
    - SameSite : 크로스 사이트 요청 제한 -> CSRF 완화
  - 고유성 보장 : 동일한 세션 ID가 동시에 재발급되지 않도록 보장
 
- 세션 만료 정책 :
  - 유휴 타임아웃 : 일정 시간 요청이 없으면 세션을 자동 만료시킵니다.
  - 절대 타임아웃 : 세션이 생성된 지 일정 시간이 지나면 무조건 만료
  - 강제 로그아웃 : 관리자가 특정 사용자의 세션을 강제로 만료
 
- 세션 고정 방지
  - 공격자가 미리 발급받은 세션 ID를 피해자에게 강제로 사용하게 하면, 로그인 후에도 공격자가 동일 세션을 이용할 수 있음
 
- 로그아웃 처리
  - 서버 측 세션 무효화 : 세션 저장소에서 해당 세션 ID 삭제.
  - 클라이언트 쿠키 만료 지시 : Max-Age=0 또는 Expires 속성을 이용해 브라우저 쿠키를 제거합니다.
  - 즉시 반영 : 로그아웃 요청 시 즉시 세션이 무효화되어야 하며, 남아있는 요청이 더 이상 인증되지 않아야 합니다.
 
- 추가 고려사항
  - 동시 세션 제어 : 동일 사용자가 여러 기기에서 로그인할 경우 정책적으로 허용/제한할지 결정
  - 세션 하이재킹 대응 : 비정상적인 위치에서 세션 접근 시 알림 또는 강제 만료 처리
  - 로그 및 모니터링 : 로그인/로그아웃, 세션 만료, 실패 시도 등을 로깅하여 추적 가능성 확보
  - 전송 계층 보안 : 세션 쿠키는 반드시 TLS(HTTPS)를 통해서만 전송해야 함
 
## 쿠키와 세션 보안 설정
#### Secure
- 암호화된 연결(HTTPS) 에서만 쿠키가 전송되도록 제한.
- 네트워크 구간에서 쿠키가 노출될 위험을 크게 줄여줌 (중간자 공격에 의해 쿠키가 탈취될 위험을 완화)
- 서비스 전체가 HTTPS를 사용해야 함. 운영환경에서는 HSTS도 함께 고려

- HSTS
  - 클라이언트에게 "이 도메인은 무조건 HTTPS로만 접속해야 한다"는 정책을 전달하는 HTTP 응답 헤더
 
- 운영 환경에서는 HTTPS 강제 리다이렉트와 HSTS를 함께 적용.
- 개발 환경에서는 로컬 인증서(mkcert)를 사용해 HTTPS를 손쉽게 구성

#### HttpOnly
- 브라우저 자바스크립트에서 쿠키 접근을 차단 XSS로부터 쿠키 읽기를 어렵게 만들어 세션 탈취를 완화
- document.cookie 로 쿠키 값을 읽을 수 없음
- 악성 스크립트가 쿠키를 훔쳐가는 것을 차단
- XSS 자체를 없애지는 않음. 단지 쿠키 탈취를 막아줄 뿐이며 DOM 조작 등은 여전히 가능함.

- 인증에 쓰는 모든 쿠키는 기본값으로 HttpOnly 사용.
- SPA에서도 인증 토큰을 localStorage에 저장하지 말고, 가능하면 HttpOnly 쿠키 사용
  - 동적 랜더링 - UX up / SEO down / 사용자 만족은 올라가지만 검색 사이트에 노출이 안됨
- CSP, 출력 인코딩 등 XSS 방어도 함께 적용

#### SameSite
- 다른 사이트에서 오는 요청에 쿠키가 자동으로 첨부되는지 제어하여 CSRF 완화
- 옵션
  - Strict 크로스 사이트 모든 내비게이션에서 쿠키 미전송 : 민감한 백오피스 - 소셜 로그인, 외부 리디렉션 시 불편
  - Lax 대부분의 크로스 사이트 요청에서 미전송, 탑 레벨 GET 네비게이션은 예외 : 일반 웹앱 기본값 - 폼 POST, XHR, iframe 요청은 미전송
  - None 출처 상관없이 전송 : 제 3자 쿠키 필요(SSO, 임베드) - 반드시 Secure 동반
 
#### CSRF 공격
- 사용자가 자신도 모르게 공격자가 의도한 요청을 특정 웹 애플리케이션에 보내도록 속이는 공격
- 피해자가 로그인하여 인증 쿠키를 보유 중일 때, 공격자가 조작된 링크나 폼을 열게 하면 브라우저가 자동으로 쿠키를 첨부하여 서버에 요청을 보냅니다.

## 기본 인증
- ***RFC 7617***
  - HTTP 표준 인증 방식 중 하나로, RFC 7617에서 정의되어 있음.
  - 사용자 이름과 비밀번호를 콜론(:)으로 연결한 뒤 Base64로 인코딩하여 Authorization 헤더에 담아 서버에 전달
  - 매우 단순한 구조 덕분에 구현이 쉽지만, 보안적으로 취약
 
- 기본 개념
  - 클라이언트 : 사용자 이름과 비밀번호를 준비
  - 인코딩 : 이 문자열을 Base64로 인코딩
  - 서버 요청 : 인코딩한 문자열을 Authorization 헤더에 담아 요청 전송
  - 서버 동작 :
    - Authorization 헤더 확인
    - "Basic" 접두사 제거 후 Base64 디코딩
    - 사용자이름:비밀번호 추출
    - 서버 저장소의 자격 증명과 비교 후 인증 성공 여부 결정
   
- 기본 인증의 한계와 보안 위험성
  - Base64는 단순 인코딩일 뿐, 보안 기능이 없음
  - 재전송 위험: 요청마다 자격 증명이 반복 전송되므로 탈취 위험이 높습니다.
  - 저장소 문제 : 서버는 사용자 비밀번호를 안전하게 저장(해시, 솔트 등)해야 하며, 그렇지 않으면 유출 위험이 큼
  - 현대적 대체 수단 필요 : 실제 서비스에서는 세션 기반 인증이나 토큰 기반 인증이 일반적으로 사용 됨.
 
#### 인코딩
- 인코딩은 데이터를 다른 표현 규칙으로 바꾸는 것
- 내용 자체는 변하지 않고, 표현 방식만 달라짐

- 필요성
  - 서로 다른 언어나 기기에서도 같은 정보를 주고받기 위해 필요
  - 어떤 통로는 한글이나 특수문자를 제대로 못 읽음, 이럴 때 인코딩으로 안전하게 바꿔야 함.
  - 텍스트 파일, 이메일, 웹 요청 등에서 문제가 생기지 않도록 도움

#### 기본 인증 보안 고려사항
- HTTP로 Basic Auth를 사용하면 Authorization 헤더가 그대로 노출됨

- HTTPS 내부 동작
  - 클라이언트Hello : 브라우저가 서버에 HTTPS로 통신할래 라고 신호를 보냄. 지원 가능한 암호화 방식 목록을 함께 보냄
  - 서버Hello + 인증서 : 서버는 사용할 암호화 방식을 고르고, 자신이 신뢰할 수 있는 서버임을 증명하는 디지털 인증서(공개키 포함)를 보냄
  - 키 교환 : 브라우저는 서버의 공개키로 임시 대칭키(세션키)를 암호화해 전달
  - 세션 키 확립 : 서버는 개인키로 이를 복호화하여 같은 대칭키를 얻음
  - 대칭키 암호화 통신 시작 : 이후 모든 HTTP 요청/응답은 이 대칭키로 암호화되어 전송
  
- 세션키(비밀키)를 얻기 전까지 공개키로 암호화 -> 최초 공개키로 세션키를 암호화 해 전달 -> 개인키로 복호화(세션 키 획득) -> 이후 데이터는 세션키로 암호화

#### 자격 증명 노출 위험성 BASE64는 암호화가 아님
#### 현대 웹 애플리케이션에서의 활용
- 매 요청마다 ID/PW 전체를 보내는 구조라 매우 위험
- 세션/토큰 기반 인증이 더 안전하고 효율적

## 토큰 기반
#### Authorization 헤더
- HTTP 요청에서 인증 정보를 서버로 전달하기 위해 사용하는 표준 헤더
- 서버가 클라이언트의 신원을 확인하고 보호된 리소스 접근 권한을 부여하는 데 사용
- 두 가지 요소
  - 인증 방식 : Basic, Bearer(JWT, OAuth), Digest
  - 자격 증명 또는 토큰 : 암호화,인코딩된 값
 
- 세션 기반 인증과의 차이점

| 구분            | 세션 기반 인증             | Authorization 헤더 기반 인증 |
|----------------|------------------------|---------------------------|
| 인증 정보 저장 위치 | 서버(세션 저장소)          | 클라이언트(토큰 등)            |
| 전송 방식        | 쿠키                    | 헤더                        |
| 상태 관리        | 서버가 상태를 유지          | 서버는 무상태로 동작 가능        |
| 확장성           | 서버 확장 시 세션 동기화 필요 | 토큰만 검증하면 되어 확장성 높음  |

#### 토큰 기반 자격 증명 방식
- 특징
  - 토큰에 포함된 인증 정보는 서버가 별도로 상태를 저장하지 않음
  - 생성된 토큰을 HTTP Authorization 헤더에 담아 전송
  - 토큰 안에 사용자 정보가 포함되므로, 세션에 비해 네트워크 트래픽이 많을 수 있음
  - 서버는 토큰 자체를 관리하지 않으므로, 보안성 측면에서 더 신중한 설계가 필요
  - 인증 상태를 서버에 저장하지 않기 때문에 확장성 면에서 매우 유리
  - 토큰 유출 시 위험 : 토큰은 암호화되지 않은 사용자 정보를 포함할 수 있으므로, 민감한 정보는 토큰에 넣지 않아야 함.
  - 토큰은 만료되기 전까지는 기본적으로 무효화가 불가능
  - CSR(Client Side Rendering) 방식의 애플리케이션에 적합
 
#### JWT (JSON Web Token)
- 데이터를 안전하고 간결하게 전송하기 위해 고안된 인터넷 표준 인증 방식
- JSON 포맷으로 사용자 정보를 담음
- 담긴 정보를 Base64URL로 인코딩
- 마지막으로 Secret Key와 알고리즘을 이용해 서명을 추가하여 위변조 방지

- 구조
  - Header.payload.signature
  - header : 어떤 알고리즘으로 서명했는지, 어떤 타입의 토큰인지 정의
  - payload : 사용자 정보와 클레임 데이터가 담김
  - signature : 헤더와 페이로드가 변조되지 않았음을 검증
 
- Access Token과 Refresh Token
  - Access Token
    - 목적 : API 요청 시 인증/인가
    - 유효 기간 : 짧음
    - 보관 위치 : 보통 메모리/스토리지
  - Refresh Token
    - Access Token 재발급
    - 김
    - 안전하게 보관 필요
   
- 민감한 정보 포함 금지
- 토큰 만료 시간 설정
- HTTPS 사용
- 저장 위치 주의
- 토큰 무효화 전략

#### Refresh 토큰
- 토큰을 두 개로 나누는 이유
  - 보안성 강화
  - 사용자 경험 개선
 
- 토큰 만료 및 무효화 처리
  - Access 토큰 만료
    - 기본적으로 수분 ~ 수십 분 단위.
    - 탈취 위험 시, 피해를 최소화하기 위함.
  - Refresh 토큰 만료
    - 보통 일 단위 또는 주 단위
    - 장기간 보관되므로 DB저장 후 화이트리스트/블랙리스트 방식으로 관리하는 경우도 많음
  - 무효화 전략
    - 강제 로그아웃 : 서버 DB에서 Refresh 토큰을 제거
    - 토큰 로테이션: Refresh 토큰 사용 시마다 새 Refresh 토큰 발급, 이전 것은 무효화.
   
## 인가
- 인증된 사용자가 어떤 자원에 접근할 수 있는지 결정하는 과정

- 필요성과 역할
  - 보안 강화 : 인증만으로는 충분하지 않으며, 각 사용자마다 허용된 범위를 제한해야 함.
  - 자원 보호 : 중요 데이터나 관리자 기능은 권한이 있는 사용자만 접근할 수 있어야 함.
  - 사용자 경험 : 불필요한 접근을 막아 사용자가 본인 권한 범위 내에서만 기능을 이용하도록 돕는다.
 
- 분리해야 하는 이유
  - 보안 경계 명확화
    - 인증은 *신원 확인*, 인가는 *행위 허용 여부*
    - 섞이면 신원 미확정 상태에서 권한을 부여하는 오류가 생길 수 있음
  - **책임 분리(SRP)**
    - 인증 모듈은 크리덴셜 검증에 집중, 인가 모듈은 정책(규칙) 판단에 집중 -> 코드 단순화,테스트 용이성, 교체 용이성 향상
  - 정책 진화,확장 용이
    - 비즈니스가 커질수록 권한 규칙은 잦은 변경 필요
    - 인증과 분리하면 정책만 바꿔도 됨
  - 감사,추적 품질 향상
    - 누가(인증) 무엇을 시도했고(행위), 왜 허용/거부되었는지(정책)를 분리 로깅하면 사고 분석이 쉬워짐
  - 취약점 예방
    - 섞이면 대표적으로 IDOR(수평 권한 상승), 권한 누락 체크 같은 문제가 자주 발생
   
- 인가가 인증 이후여야 하는 이유
  - **신원 미확정 상태에서는 권한 판단 불가**
  - 토큰/세션 위조 방지
  - 오류 시 안전한 기본값
 
#### 권한 기반 접근 제어
- 용어 정리
  - 사용자 : 시스템을 이용하는 주체
  - 역할 : 사용자의 업무 묶음
  - 권한 : 특정 리소스에 대한 행위 허용 규칙
  - 리소스 : 보호 대상
  - 행위 : 리소스에 대한 조작
  - 정책 : 조건이 있는 권한 규칙
 
- RBAC(역할 기반)의 핵심
  - RBAC는 사용자 <> 역할 <> 권한을 매핑
  - 사용자는 역할을 부여받고, 역할에 권한을 부여
  - 선택 이유
    - 관리 용이
    - 일관성
    - 감사 용이
   
- 권한 설계 5대 원칙
  - 최소 권한 : 필요한 최소 권한만 부여
  - 기본 거부 : 명시적으로 허용된 것만 허용
  - 책임 분리 : 서로 충돌 가능한 권한을 분리
  - 감사 가능성 : 누가/무엇을/왜 했는지 추적 가능해야 함
  - 단순성 우선 : 정책은 이해,검토,운영이 쉬워야 함
- **권한은 추가보다 회수가 어려움**

- 도메인 인벤토리: 리소스,행위 목록화
  - 권한 설계는 도메인을 리소스와 행위로 쪼개는 일에서 시작.
 
- 역할 도출 방법
  - 업무 단위로 묶기 : 실사용자의 업무 시나리오에서 공통 행위를 묶어 역할 후보를 만듦
  - 최소 공통권한과 확장 권한을 분리
  - 충돌 권한 분리 : 생성자와 승인자를 분리하는 등 SoD 적용.
 
- 권한 매트릭스 작성

- 정책 조건 설계 : RBAC 한계를 보완
  - 소유 기반 : POST.UPDATE는 userId == ownerId일 때만 허용한다.
  - 상태 기반 : POST.DELETE는 status == DRAFT 일때한 허용한다.
  - 시간/위치 기반 : EXPORT는 근무시간 내 사내망에서만 허용
  - 리스크 기반 : 고액 ORDER.REFUND는 2인 승인 필요
  - 정책은 역할 권한을 필터링하거나 추가 제약을 주는 형태로 동작
 
## 실제 인가 구현 사례
#### 게시물 접근 권한 관리
- 기본 정책 정의
  - 게시물 읽기 : 모든 로그인 사용자
  - 게시물 작성 : 로그인 사용자
  - 게시물 수정 : 작성자 본인
  - 게시물 삭제 : 작성자 본인 / 관리자
 
#### API 엔드포인트 권한 관리
- 엔드포인트 정책
  - 엔드포인트마다 접근 권한 설정 가능
 
#### 관리자와 일반 사용자 권한 구분
- 관리자와 일반 사용자를 구분하여 가능
- 역할 기반 구분
  - 관리자 : 시스템 설정, 모든 데이터 접근, 사용자 관리
  - 일반 사용자 : 본인 데이터 접근, 서비스 기본 기능 사용
 
## 세션/토큰 기반 인가
#### 세션
- 사용자가 로그인하면 서버는 세션 객체를 생성
- 이 객체 안에는 사용자 정보와 함께 권한 정보도 함께 저장
- 세션은 서버 자원을 소모하므로 확장성이 떨어질 수 있음
- 세션 저장소를 외부 캐시 서버(Redis, Memcached)로 구성하면 확장성 문제를 완화할 수 있음
- 세션이 만료되면 자동으로 권한도 무효화

#### 토큰
- JWT는 인증 정보를 클라이언트가 직접 보관하는 방식
- Header.Payload.Signature 중 Payload에 권한 정보를 포함
- JWT는 탈취되면 만료 전까지 무효화 불가 / Refresh Token과 함께 사용
- payload는 base64로 인코딩된 것이므로, 민감 정보는 포함하지 않음
- 서버는 무상태 구조를 유지할 수 있어 대규모 서비스에 적합

#### 권한 정보 관리 모범 사례
- 최소 권한 원칙
  - 사용자가 업무 수행에 꼭 필요한 최소한의 권한만 가지도록 설계
- 중앙 집중 관리
  - 권한 정책은 코드 여러 곳에 흩어지지 않고, 중앙 관리 모듈을 통해 관리해야 함
- 로그와 모니터링
  - 권한 검증 실패는 보안 이벤트로 기록해야 함
- 계층적 권한 설계
  - USER < EDITOR < ADMIN 처럼 계층적 구조를 도입하면 권한 관리가 단순해짐
  - 권한 설계를 초기에 잘못하면 유지보수가 어려워 짐
 
## OAuth
- 비밀번호는 절대 주지 말고, 필요한 범위만 토큰으로 위임
- 기존 문제
  - 서비스가 늘수록 사용자 비밀번호가 여러 곳에 흩어져 저장됨
  - 외부 API를 쓰려면 그 서비스의 비밀번호까지 보관해야 할 수 있음
  - 유출 시 피해가 크고, 비밀번호 변경 동기화도 어려움
 
- 써드 파티 API 연동 시 발생하는 추가 문제
  - 일정 서비스가 Google Calendar API를 쓰려면 사용자의 구글 비밀번호를 받아 저장해야 하는 상황이 생김
  - 사용자가 구글 비밀번호를 바꾸면 일정 서비스에도 다시 알려주어야 함
  - 다른 서비스가 내 비밀번호를 갖고 있다는 사실 자체가 큰 보안 리스크
 
- OAuth2
  - 비밀번호 대신 토큰으로 권한 위임
  - 신뢰 가능한 인증 서버(ex:google)가 인증을 담당하고, 애플리케이션(클라이언트)에게 Access Token을 발급
    - 애플리케이션은 이 토큰으로 리소스(API)를 사용
   
  - 핵심 변화
    - 비밀번호는 절대 공유되지 않음
    - 토큰 + 범위로 필요한 권한만 위임
    - 관리해야 할 크리덴셜 수가 줄어들어 보안성 향상
   
- OAuth2를 사용하는 애플리케이션 유형
  - 써드 파티 API를 직접 사용하는 서비스
  - 로그인 수단으로 제공

**OAuth2 중요성**

|관점	|전통적 방식 |	OAuth 2 방식	| 의미 |
|----|----------|-------------|-----| 
|비밀번호 처리 |	서비스가 직접 저장 |	저장하지 않음 |	유출면적 감소|
|권한 범위|	계정 전체 |	Scope 단위 최소 권한 |	과도권한 방지|
|연결성	|서비스마다 계정 필요 | 하나의 계정으로 다수 서비스 연동 |	UX 향상|
|유지관리	|변경 동기화 필요 |	토큰 재발급/만료 관리 |	운영 단순화|
|보안 사고 | 치명적(비번 유출) |	토큰 만료/회수로 피해 축소 |	리스크 완화|

#### 적용 체크 리스트
- 서비스 요구사항 확인
  - 써드 파티 API 연동이 필요한가
  - 자체 로그인만으로 충분하지 않은가
- 보안 고려
  - 비밀번호를 직접 수집하거나 저장하지 않고 OAuth만으로 인증 가능한가
  - HTTPS를 강제하여 토큰 탈취 위험이 줄였는가
  - Access Token 저장소를 안전하게 설계 했는가
- 토큰 관리 정책
  - 토큰 무효화 전략을 마련했는가
- Scope 설정
  - 최소 권한 원칙을 적용했는가
  - 실제로 필요한 API 권한만 요청하는가
- 사용자 경험
  - 소셜 로그인 버튼을 통해 직관적인 UX를 제공하는가
  - 기존 회원 계정과 소셜 로그인 계정을 어떻게 매핑할지 정책이 정의되어 있는가
- 운영 및 모니터링
  - 토큰 발급 및 만료 이벤트를 로깅하고 있는가
  - OAuth 인증 실패율, 토큰 재발급 빈도 등을 모니터링할 수 있는가
 
#### OAuth 2 인증 컴포넌트
- Resource Owner (User)
  - Resource(자원)의 실제 소유자
  - OAuth 2 프로세스에서 최종 결정권을 가진 주체
 
- Client
  - Resource Owner를 대신하여 Resource에 접근하는 애플리케이션 (스프링 서버)
  - 서버, 웹, 모바일 등 다양한 형태가 될 수 있음
  - 서비스 제공자가 아니라 서비스를 이용하고자 하는 쪽이 Client
 
- Resource Server
  - 보호된 자원을 실제로 저장하고 있는 서버
  - Client의 요청을 Access Token으로 검증하고, 올바르다면 자원을 반환
  - 실제 데이터가 존재하는 곳
 
- Authorization Server
  - Resource Owner의 인증을 처리하고, Client에게 AccessToken을 발급하는 서버
  - OAuth 2에서 가장 중요한 역할을 맡고 있으며, 자격 증명의 신뢰성을 보장
  - Access Token 발급자

#### 컴포넌트 간 상호 작용
- Resource Owner는 Client에게 로그인 요청
- Client는 자체 로그인 창이 아닌, 써드 파티 서비스의 로그인 페이지로 리다이렉트
- Resource Owner는 Authorization Server에서 직접 로그인
- 로그인 성공 시 Authorization Server는 Client에게 Access Token을 발급
- Client는 발급받은 Access Token을 이용해 Resource Server에 요청
- Resource Server는 Access Token을 검증한 뒤, 요청한 자원을 Client에게 반환
