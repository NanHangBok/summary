#DAY_ 63

## 목차
- [ECR 수명주기](#ecr-수명주기)
- [ECS](#ecs)
- [CI](#ci)
- [CD](#cd)

---

## ECR 수명주기
- 오래된 이미지 자동삭제
- 자동 청소기 역할
  - 매번 수동으로 오래된 이미지를 지우지 않아도 된다.
  - 정책에 맞춰 자동으로 오래된 이미지 삭제가 이루어진다.
- 저장 비용 절감
  - ECR 저장소는 GB 단위로 요금이 청구됨
  - 사용하지 않는 오래된 이미지를 자동 삭제하면 비용 절약 효과가 있음
- 운영 효율성
  - "어떤 이미지가 최신이고, 어떤 건 더 이상 필요 없는지"를 고민할 필요가 줄어듬
  - 팀원들도 혼란 없이 최신 이미지만 사용할 수 있음
- 보안 측면
  - 옛날 이미지가 그대로 남아 있으면 취약점 스캐너에 걸릴 수도 있음
  - 필요 없는 이미지를 주기적으로 정리해서 보안 위험을 줄인다

## ECS
- AWS에서 제공하는 컨테이너 오케스트레이션 서비스
- ECR에 저장된 Docker 이미지를 불러와 클러스터 환경에서 실행할 수 있음
- 클러스터 내에서 여러 서비스와 태스크를 실행하며, 자동 확장 및 로드밸런싱 지원

- 클러스터
  - ECS에서 클러스터는 컨테이너를 실행하는 어떤 논리적 그룹
  - Fargate 모드일 경우, 실제 서버를 직접 지정하진 않지만 내부적으로 Fargate가 AWS 리소스를 할당해 컨테이너를 구동
  - EC2모드일 경우, 클러스터에는 하나 이상의 EC2인스턴스가 등록되며, 그 인스턴스 안에서 컨테이너가 동작
 
- Fargate
  - 서버 운영 부담이 없음
  - 필요한 만큼 CPU/메모리만 설정해 과금, 스케일링이 간편함
  - EC2보다 단가가 비쌈
  - 호스트 레벨에 대한 세부 조정이 어려움
 
- EC2
  - 인스턴스 타입, 네트워크 설정, OS 커스터마이징 등에 대한 자유도가 높음
  - 고성능-고밀도 배포 상황에서 비용 효율이 나올 수 있음
  - EC2인스턴스를 직접 띄우고 관리해야 하므로 운영 부담이 생김

#### ECS 작업 정의
- ECS에서 실행할 애플리케이션의 설계도
- 어떤 이미지를 사용할지, CPU/메모리 자원은 얼마인지, 어떤 포트를 열어줄지 등을 지정
- 실제 컨테이너 실행은 작접 정의를 기반으로 이루어짐

#### ECS 서비스
- ECS에서 특정 작업 정의를 기반으로 여러 개의 작업을 실행하고 관리하는 단위
- 단순히 한 번 실행되는 작업과 달리 서비스는 지속적응로 실행되며 중단되면 자동으로 재시작
- 작업 개수를 지정하여 컨테이너를 여러 개 실행할 수 있으며, 로듭ㄹ런서와 연결하여 트래픽을 분산할 수도 있음

## CI
- 지속적 통합은 서비스 전달에 앞서 반드시 선행되어야 하는 과정
- 사람의 실수를 줄이는 자동화 과정
- 과정
  - Plan
  - Code
  - Build
    - 소스 코드를 실행 가능한 산출물로 변환하는 과정
  - Test
  - Release
  - Deploy
  - Operate
- 빌드 도구
  - 수동 빌드는 복잡, 번거롭고 오류가 많음
  - 프로젝트 규모가 커질수록 의존성 관리와 빌드 작업이 까다로워짐
  - 빌드 도구는 이를 자동화하여 효율적이고 안정적인 릴리스를 가능하게 함
 
- 개념
  - 개발자가 작성한 코드를 짧은 주기로 중앙 저장소에 통합하고, 자동으로 빌드와 테스트를 실행하는 프로세스
- 필요성
  - 오랫동안 따로 작업한 코드를 한꺼번에 합치면 -> 충돌, 빌드 실패, 에러 폭발
  - CI는 코드 변경 시마다 자동으로 빌드/테스트하여 -> 문제를 빠르게 발견하고 해결

- CI가 없을 떄
  - 충돌 증가
  - 버그 추적 어려움
  - 배포 지연
 
- 자동화된 빌드와 테스트
  - 자동 빌드 : 코드가 push되면 자동으로 빌드
  - 자동 테스트 - 단위 테스트, 통합 테스트 실행
  - 결과 알림 - 실패 시 Slack, 이메일 등으로 즉시 알림
 
- 효과
  - 코드 품질 향상
  - 빠른 피드백
  - 효율성 증가
 
- 원칙과 프로세스
  - 버전 관리 시스템에 코드 등록 -> CI 서버가 자동 빌드 & 테스트
  - 결과를 개발자에게 즉시 알림
  - 문제가 있으면 빠르게 수정
  - 문제가 없으면 코드 릴리스

## CD
- 지속적 배포는 지속적 통합 이후 단계로, 빌드와 테스트를 통과한 코드를 자동으로 배포하는 프로세스를 의미
- 지속적 전달 : 코드가 항상 배포 가능한 상태로 준비되며, 실제 프로덕션 배포는 최종적으로 사람이 승인
- 지속적 배포 : 코드가 준비되면 승인 과정 없이 자동으로 프로덕션에 배포

#### 배포 자동화
- 서비스가 복잡해지고 규모가 커질수록 배포 과정도 복잡해지고 시간이 오래 걸림
- 서비스 변경 사항이 생길 때 마다 수동으로 배포해야 한다면 많은 시간을 허비하게 됨
- 장점
  - 반복적이고 수동적인 작업 제거
  - 배포 속도 단축 -> 개발자가 더 빠르게 애플리케이션 배포 가능
  - 일관성 & 안정성 확보 (자동화된 작업이 동일하게 실행됨)
  - 사람의 실수를 줄이고 생산성을 높임
 
- 자동화된 배포 프로세스
  - CI 결과물
  - 아티팩트 생성
  - 저장소 업로드
  - 배포 자동화
```
1. CI가 빌드/테스트 완료 -> 아티팩트(실행 가능한 결과물) 생성
2. 아티팩트를 저장소에 업로드
3. 배포 스크립트 또는 툴이 자동 실행
4. 서버 또는 클라우드 서비스에 반영
```

- 배포 파이프라인 단계
  - Source 단계 - 원격 저장소 코드 변경 감지
  - Build 단계 - 코드를 컴파일, 빌드, 테스트하고 결과물 생성
  - Deploy 단계 - 결과물을 실제 서비스 환경에 반영


## 이슈
- docker push 시 ecr에 InitiateLayerUpload denied 발생
  - user 권한에 추가해도 dinied 발생
  - ecr 권한에
  - ```
    {
      "Version": "2008-10-17",
      "Statement": [
        {
          "Sid": "AllowPushForDevCodeitUser",
          "Effect": "Allow",
          "Principal": {
            "AWS": "arn:aws:iam::<ACCOUNT_ID>:user/dev-codeit"
          },
          "Action": [
            "ecr:PutImage",
            "ecr:InitiateLayerUpload",
            "ecr:UploadLayerPart",
            "ecr:CompleteLayerUpload"
          ]
        }
      ]
    }
    ```
  - 추가 시 해결










