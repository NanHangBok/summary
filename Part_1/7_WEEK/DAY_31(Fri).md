# DAY_31

- [REST](#rest)
- [GraphQL](#graphql)
- [gRPC](#grpc)
- [마이크로서비스 아키텍처 (MSA)](#마이크로서비스-아키텍처-msa)
- [서버리스 아키텍처](#서버리스-아키텍처)
  - [Firebase](#firebase)
  - [Supabase](#supabase)
- [API 경제](#api-경제)
- [API 설계 원칙](#api-설계-원칙)
  - [API 엔드포인트 설계 원칙](#api-엔드포인트-설계-원칙)
  - [요청 설계](#요청-설계)
  - [응답 설계](#응답-설계)
- [버전 관리](#버전-관리)
- [하위 호환성 유지 (유연한 설계)](#하위-호환성-유지-유연한-설계)
- [점진적 변경 적용 절차](#점진적-변경-적용-절차)
- [API 품질 요소](#api-품질-요소)
- [API 품질]{#api-품질)

## REST
무상태성
- 서버가 각 호출의 상황을 기억하지 않는다는 의미
- 상태(정보)가 없기 때문에 반복적인 정보(AccessToken)을 호출 매번 모두 포함 -> 누가 호출했는지 인증/인가

일관성
- HTTP 메서드와 자원 중심 URI 구조를 일관되게 사용한다

확장성
- REST는 자원 중심 설계
- 규칙만 잘 지키면 쉽게 확장 가능
- 새로운 기능이 생기더라도 기존 URI 설계 원칙을 유지하면서 자연스럽게 확장 가능

한계
- Over-fetching : 필요한 정보보다 더 많은 데이터를 가져옴
- Under-fetching : 원하는 정보를 다 얻으러면 여러 번 요청해야 함
- API 버전 관리 문제 : URL에 /v1, /v2 등 버전이 섞여가며 복잡해짐

## GraphQL
- 쿼리 기반 데이터 요청
- 클라이언트가 필요한 필드만 선택해서 요청할 수 있음
- 장점
  - Over-fetching 해결
  - Under-fetching 해결
  - 스키마 중심
  - 버전 관리 불필요
 
- 단점
  - 캐싱이 어렵고, 보안 필터링 로직이 복잡해질 수 있음
 
## gRPC
- 이진 포맷 사용
- HTTP/2 기반으로 양방향 스트리밍, 서버 푸시, 멀티플렉싱 등 고성능 기능 지원 / 빠름
- 내부 마이크로서비스 간 통신에 매우적합

- 장점
  - 고성능
  - 양방향 스트리밍
  - 다양한 언어 지원
  - API 명세와 코드 동기화

- 단점
  - 브라우저 지원 불완전
  - 디버깅이 어려움
  - 외부 API 제공 부적합

 ## 마이크로서비스 아키텍처 ( MSA)
 - 기존 모놀리식 구조 문제점
   - 한 기능의 작은 수정도 전체 재배포 필요
   - 기능 간 결합도가 높아 유지보수 어려움
   - 수평 확장이 어려움 (전체 시스템만 복제 가능)

 - 주요 특징
   - 독립성 : 기능별 독립 서비스 운영
   - API 중심 : 모든 서비스는 API를 통해 통신
   - DB 분리 : 서비스별 전용 데이터베이스 권장
   - 팀 분리 : 도메인 중심 팀 운영 가능
   - JSON을 주고받기 떄문에 언어에 제약 받지 않는다

- 서비스 간 API 통신
  - REST
  - gRPC
  - 메시지 브로커 (이벤트 기반 비동기 통신)
    - KAFKA, RabbitMQ, Redis stream 등
    - 서비스 간 느슨한 연결 -> 실패 시 재처리 가능

- Gateway
  - 라우팅
  - 인증/인가
  - 공통 응답 포맷, 에러 처리
 
- 도전 과제
  - 분산 트랜잭션
 
## 서버리스 아키텍처
- 개발자가 서버를 직접 관리하지 않는 구조 (서버가 없는 것 처럼)
- 특징
  - 유지보수 부담
  - **과금 모델** : **사용한 만큼만 지불** / 이용이 적을 때 경제적
  - 확장성
  - **배포 속도** : 함수 단위로 배포 가능
 
- 단점과 제한
  - cold Start : 오랜 시간 호출되지 않으면 첫 실행에 지연 발생
  - 단기 실행 제약 : AWS Lambda는 최대 15분, 그 이상의 작업은 step Function 등 필요
  - 상태 관리 어려움 : 상태 유지가 불가능하므로 외부 DB나 Redis 등 활용 필요
  - 모니터링 난이도

#### firebase
- 구글 기반 완성형 BaaS(backend-as-a-Service)
- 핵심기능
  - Firebase Authentication
  - Firestore / Realtime DB
  - Cloud Functions
  - FCM
 
- 장점
  - 강력한 실시간 기능
  - 모바일 앱과의 강력한 통합
  - 클라이언트 SDK 풍부
 
- 단점
  - 유료 요금제로 갈수록 가격이 급상승
  - NoSQL만 지원 -> 복잡한 쿼리 어려움
  - 지역 서버 위치 선택 제한
 
- 모바일, 실시간 앱
 
#### supabase
- 오픈서버 기반 Firebase 대안
- PostgreSQL 기반 서버리스 백엔드 플랫폼
- 서버리스 함수, 실시간 구독, 인증, 스토리지 등 firebase와 유사한 기능 제공
- 핵심 기능
  - supabase Auth
  - Supabase DB
  - Edge Functions
  - Realtime
  - Storage
 
- 장점
  - SQL 기반 -> 복잡한 쿼리도 자연스럽게 처리
  - 오픈소스 기반
  - gitHub 연동으로 CI/CD 간편
 
- 단점
  - 실시간 기능은 firebase보다 약함
  - Edge Functions는 아직 베타 수준
  - 한국 리전은 유료 플랜 필요
 
- 웹 서비스, SaaS

## API 경제
- 기업이 API를 자산화하여 기능, 데이터, 서비스 등을 외부에 제공하고 이를 통해 비즈니스 가치를 창출하는 일련의 경제 모델
- 수익화 모델
  - 과금형
  - 프리미엄형
    - 속도/ 요청 수/ 보안 기능/ 해상도 등급 차등화를 제공해야 함
  - 파트너형
    - 계약 기반관리, 사용량 제한, 비공개 문서 관리 체계 중요
  - 간접 수익형

## API 설계 원칙
- 일관성
  - 일괄된 URI 패턴
    - URI는 명사 기반의 리소스 구조로 행동은 METHOD로
  - 응답 필드 네이밍 규칙 통일
    - 응답 필드의 규칙은 프로젝트 내에서 반드시 하나로 통일 / camelCase 통일 등
  - 상태 코드의 명확한 구분
    - 비슷한 오류도 명확히 구분해야 함
  - 일관된 필드명,구조 사용
    - 일정 리소스를 다루는 모든 엔드포인트에서 동일한 필드명, 동일한 데이터 구조 유지
    - 일정 관련 응답이 한상 같은 구조를 따르므로 코드 재사용성이 쉬워지고, API 문서를 매번 참고할 필요도 줄어든다.
   
- 단순성
  - 복잡한 내부 로직을 감추고, 외부 개발자가 직관적으로 이해할 수 있어야 함
  - 하나의 API는 한 가지 책임만 수행해야 한다
  - 예외 상황에 대한 처리는 명확하게, 공통화된 에러 구조로 전달해야 한다.
  - URI는 가능하면 짧고 의미 있게 구성한다.
 
- 확장성
  - 시간이 지나면서 기능이 추가되거나 변경 될 수 밖에 없기 때문에 미리 고려하여 유연한 설계가 필요
  - URI 구조는 세분화보다는 상위 구조를 유지하면서 하위 기능만 분기
  - 필수 vs 선택 파라미터 구분 명확
  - 향후 추가될 응답 필드가 있어도 구조가 꺠지지 않도록 설계
  - 선택 필터 파라미터 & 공통 페이지네이션 구조
 
- 안정성
  - 변경을 최소화하고 예측 가능한 형태로 유지하는 것
  - 변경이 잦거나 예고 없이 이뤄질 경우,프론트 오류, 클라이언트 크래시, 외부 파트너 서비스 장애까지 유발할 수 있음
 
  - 안정성을 위한 코드/설계 전략
    - 응답 필드 순서 고정
      - @JsonPropertyOrder 사용
     
    - null 값 포함 제한 -> 예측 가능한 구조 유지
      - @JsonInclude(Include.NON_NULL)을 사용하면 불필요한 필드가 응답에 포함되지 않아, 파싱 예외 위험이 줄어 듦
     
    - Deprecated 필드 명시 & 제거 주기 관리
      - @Deprecated로 코드에서 경고
      - Swagger 문서에 명확히 노출 + 제거 시점 수석 명시
     
    - URI 구조 변경 시 버전 명시 또는 Proxy 유지
      - /api/v1/users -> /api/v2/users
      - 기존 v1 URI도 일정 기간 유지
      - 또는 API Gateway에서 v1 -> v2 리다이렉트 처리
     
#### API 엔드포인트 설계 원칙
- 명확한 의도 전달
  - 리소스 중심으로 표현, 행동은 메서드로 구분
 
- 계층 구조화
  - 자원의 상하 관계가 존재할 경우, URI를 계층적으로 표현
 
- 명명 규칙
  - 복수형 사용
  - 동사 대신 명사 사용
  - 케밥 케이스 권장(kebab-case) / 소문자 + 띄워쓰기는 (-)하이픈으로
 
- 기능 단위 분할
  - 비즈니스 기능이 복잡해질 경우, 하위 기능을 엔드포인트로 분리하는 것이 좋다

#### 요청 설계
- 데이터 구조화 (DTO 설계)
  - 유효성 검증 어노테이션을 통해 API 입력값의 신뢰성을 보장
  - Dto 내부의 Dto 유효성 검증을 위해서는 @Valid 어노테이션 필수
- 필터링과 정렬 패턴
  - 쿼리 파라미터를 사용하여 구성하는 것이 일반적
  - 검색 조건이 복잡할 경우 @ModelAttribute 또는 @RequestParam Map<String,String> 방식으로 받아 처리할 수 있습니다.

#### 응답 설계
- 일관된 응답 구조
  - success : 요청 성공 여부
  - data : 실제 응답 본문 (데이터)
  - error : 에러 정보가 있을 경우 포함 (에러 메시지, 코드 등)
  - timestamp : 서버 기준 응답 시간
 
- 예외 처리 패턴
  - 예외 핸들러 설계
 
- 페이지네이션 패턴
  - data : 실제 결과 목록
  - page : 현재 페이지 번호 (0-base)
  - size : 페이지 크기
  - totalElements : 전체 결과 수
  - totalPages : 전체 페이지 수

## 버전관리
- URL 버전 관리
  - URL 경로에 버전 정보를 직접 명시하는 방식
  - 장점
    - 버전을 URI에서 명확히 표현 -> 직관적
    - 신규 기능은 새 버전 경로로, 기존 클라이언트 영향 없음
  - 단점
    - 버전이 증가할수록 URI가 난잡해지고, 중복 증가
    - 문서 관리 및 마이그레이션 아낸 필수
   
- 헤더 기반 버전 관리
  - 버전을 HTTP 헤더에 담아 구분
  - 클라이언트가 특정 버전을 요청하면 서버가 해당 버전에 맞춰 응답
  - 장점
    - URL 깔끔함 유지
    - 같은 URI 경로에서 다중 버전 처리 가능
  - 단점
    - 헤더 파싱 및 처리 로직 필요 -> 구현 복잡도 증가
    - 문서화 시 URI로 버전 구분이 어려움
   
- 컨텐츠 협상 기반 버전 관리
  - HTTP의 컨텐트 협상 기능을 활용
  - 클라이언트가 요청 헤더의 Accept 값이 미디어 타입 형식으로 버전을 명시하는 방식
  - 특징 및 구성 방식
    - application/vnd.{회사명}.{버전}+{포맷} 형식 사용ㅌ
    - 버전을 명확히 분리하면서도 URI를 유지
    - API Gateway나 인터셉터에서 Accept 헤더 값을 기반으로 라우팅 가능
  - 장점
    - REST 철학에 부합
    - 세밀한 제어 가능
  - 단점
    - 헤더 기반이라 익숙하지 않은 개발자에게 부담 / 어려움
    - 디버깅/테스트 시 Postman이나 Swagger 같은 도구에서 헤더 설정이 번거로움
    - 서버 라우팅 복잡도 증가
   
##  하위 호환성 유지 (유연한 설계)
- API는 시간이 지나면서 진화하게 된다(변경 된다)
- 기존 클라이언트가 문제없이 동작하도록 호환성 유지

- 비파괴적 변경
  - 기존 필드는 그대로 유지하면서 선택적 필드 추가 또는 응답 확장
 
- 파괴적 변경
  - 기존 클라이언트가 정상 동작하지 않거나 오류 발생
  - 기존 필드 제거 또는 이름 변경
  - 필수 요청 파라미터 추가
  - 응답 구조 자체를 변경

## 점진적 변경 적용 절차
- 변경이 반드시 필요할 때는 기존 클라이언트가 자연스럽게 전환할 수 있도록 단계적 프로세스를 밟아야 한다.
- 단계
  - 신규 버전 배포
  - 기존 버전 Deprecation 알림 추가
    - HTTP 헤더
    - 응답 메시지 내 경고 필드 추가
  - 릴리스 노트, 공식 문서에 마이그레이션 안내
    - 신규/기존 요청 예제, 변경 포인트 설명
  - 일정 기간 후 구 버전 폐기

## API 변경 커뮤니케이션
1. 변경 문서화의 필요
   - 변경이 발생할 경우 명확하고 일관된 문서화 전략 필요  
2. 중단 정책
3. 마이그레이션 가이드

## API 품질 요소
#### 성능
- 얼마나 빠르고 효율적으로 응답하는지
- 왜 중요한가
  - 페이지 로딩 지연은 사용자의 이탈률 증가로 직결
  - 백엔드 시스템 과부하로 인해 전체 서비스 장애 위험
  - 모바일 환경이나 느린 네트워크 환경에서 더욱 치명적
- 성능 지표
  - Latency(지연시간) : 요청 -> 응답까지 걸리는 시간
  - Throughput : 초당 처리 가능한 요청 수
  - Error : 일정 시간 동안 발생항 오류 비율
  - CPU/Memory Usage : API 서버의 자원 소비량
 
- 성능 최적화 전략
  - 페이지네이션 : 데이터 양 제한
  - 지연 로딩 방지 : @EntityGraph, fetch join, DTO 조회로 N+1 문제 해결
  - 캐시 도입 : 메모리 캐시로 데이터 접근 최소화
  - 비동기 처리 : 비동기 응답으로 병렬 처리
  - 쿼리 튜닝 : 인덱스 설정, JPQL 튜닝, 조회 필드 최소화

#### 안정성
- API가 예측 가능하고 지속적으로 일관된 방식으로 작동하는지
- 안정성 확보 전략
  - 하위 호환성 유지
  - 명확한 버전 관리
  - 응답 구조 고정화 : 필드 순서, 존재 여부를 명확히 명시하여 변경으로 인한 오류 방지

#### 사용성
- API가 직관적이며 개발자가 이해하고 사용하기 쉬운 정도 (RESTful 한 URI 설계)
- 자원을 URI로 표현하고, 동작은 메서드로 구분한다
- 문서화 전략

## API 품질
- 응답 시간 : 클라이언트 요청 -> 응답 수신 까지의 총 시간
- 지연 시간 : 요청 이후 첫 응답 바이트가 도달하기 까지 걸리는 시간/ '반응성' 측정
- 처리량 : 초당 처리 가능한 요청 수
- 가용성 : 시스템이 정상적으로 동작하는 시간의 비율 99.9%, 99.99%
- 복구력 : 다른 시스템까지 영향을 주지 않고 자체 복구하거나 격리하는 능력
- 장애 전파 방지 : 전체 시스템으로 확산되지 않도록 설계
- 일관성
- 문서화
- 에러 메시지의 명확성











