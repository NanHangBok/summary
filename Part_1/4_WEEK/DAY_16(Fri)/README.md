# DAY_16

- [SPRING](#spring)
- [SPRING 핵심 철학](#spring-핵심-철학)
  - [IoC (제어의 역전)](#ioc-제어의-역전)
  - [Bean](#bean)
  - [DI](#di)
  - [AOP](#aop)
- [스프링 프레임워크](#spring-framework)
- [SpringBoot](#spring-boot)

## SPRING
#### POJO 기반 개발이 주는 장점
- 기술 독립성 확보
- 코드 순수성 유지
- 테스트 용이성
  - 객체 자체를 독립적으로 생성하고 실행할 수 있다.
  - JVM만 있으면 별도의 컨테이너 없이도 테스트가 가능하다
 
- '기능은 많되, 개입은 적게' -> POJO 기반 개발 -> 비즈니스 로직에 집중 / 생산성 향상

#### 객체지향 설계 원칙의 중요성
- 유연하고 모듈화 가능한 설계
  - DRY ( DON'T REPEAT YOURSELF )
    - 공통 기능 추출 (AOP)
      - 트랜잭션 처리, 로깅, 인증 등 반복되는 로직을 하나의 공통 관심사로 정의
    - 설정의 재사용 -> 프로파일, 빈 구성 클래스 등으로 추상화
    - XML/애너테이션 설정 간소화 (중복 제거)
    - @Transactional, @ComponentScan 등을 통해 선언만으로 반복 작업 제거
   
  - 단일 책임 원칙
    - 계층형 아키텍처 구조 (Controller , Service, Repository)를 통해 로직을 적절히 분리
    - 생성자 파라미터가 많은 클래스는 SRP 위반일 가능성이 크다 -> 리팩토링 권장
   
  - 관심사의 분리
    - AOP : 횡단 관심사 분리 ( EX: 트랜잭션, 로깅, 보안 )
    - DI : 구현 클래스에 대한 관심을 외부로 분리 -> IoC 개발
    - ApplicationContext : 설정 정보와 객체 생성을 환경으로 분리
   
#### 테스트 주도 개발 (TDD)
테스트 코드를 먼저 작성하고, 이를 만족시키는 실제 구현 코드를 작성하는 개발 방법론
- 기능 요청 또는 버그 리포트를 읽고, 그 요구사항이 무엇을 의미하는지 정확히 이해한다
- 작성
  - 단위 테스트 코드를 먼저 작성
  - 실제 코드를 작성되지 않았기 때문에 테스트 실패
- 기능 구현
  - 테스트 통과를 위한 최소한의 코드를 작성
  - 모든 테스트를 실행하고 모두 통과해야 다음 단계로
  - 실패하면 반복
- 리팩토링
- 반복

- 장점
  - 요구사항에 대한 명확한 이해와 정의
  - 안정적 리팩토링 가능
  - 회귀 오류 최소화
  - 높은 테스트 커버리지 확보
 
#### SPRING TDD
- 단위 테스트 용이성
  - IoC, DI 기반 제공 -> 각 객체를 독립적으로 생성하고 테스트 할 수 있는 환경 지원
  - 테스트 대상 객체가 내부에서 직접 의존 객체를 생성하지 않고, 외부에서 주입 받음
  - Mockito와 같은 Mocking 도구와의 결합이 용이
  - 실제 객체가 필요로 하지 않음 ( ex: service -> repository 에서 repo없이 service 테스트)
- 통합 테스트 지원
  - @SpringBootTest 어노테이션으로 전체를 컨텍스트 수준에서 테스트 할 수 있게 해줌
- 테스트 중심 개발을 유도하는 설계 철학
  - 테스트 가능한 코드를 중심에 두고 설계됨
  - POJO 기반 크래스
  - DI를 통한 구성
  - 설정과 환경 분리
  - 모듈화된 아키텍처

 ---
 
## SPRING 핵심 철학
#### IoC (제어의 역전)
- 제어 흐름을 개발자가 직접 제어하는 것이 아니라, 외부 시스템(컨테이너)이 대신 제어하는 아키텍처 관점에서의 개념
- 주로 프레임 워크에서 많이 등장
- ##### 프레임워크
  - 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 일련의 협업화된 형태로 클래스들을 제공하는 것
  - 일종의 큰 틀이나 외형적인 구조를 의미
  - 애플리케이션을 만들기 위한 틀 혹은 구조를 제공한다
  - 장점
    - 개발 시간을 줄일 수 있다
    - 정형화되어 있어 일정 수준 이상의 품질을 기대할 수 있다
    - 유지 보수가 쉽다
  - 단점
    - **사용법 습득에 시간이 오래 소요될 수 있다 -> 러닝 커브 (learning curve)**
    - 지나치게 의존하면 개발자의 능력이 저하되어 직접 개발하는 것이 어려워 질 수 있다
    - 규칙이 있기 때문에 어느정도 종속된다. ( 자유롭고 유연한 개발이 어려울 수 있다 )
  - 종류
    - 영속성 Framework ( DB와 관련 )
      - 데이터의 저장, 조회, 변경, 삭제를 다루는 클래스 및 설정 파일을 라이브러리화 하여 구현한 프레임워크
    - 자바 Framework
      - Java EE를 통한 웹 어플리케이션 개발에 초점을 맞추어, 필요한 요소들을 모듈화 하여 제공하는 프레임워크
    - 화면 구현 Framework
      - Front-end를 보다 쉽게 구현할 수 있도록 제공하는 프레임워크
    - 기능 및 지원 Framework

- IoC 구조
  - 기존에는 개발자가 필요한 객체를 직접 생성하고, 관리하며, 호출한다.
  - 객체 간 결합도가 높아지고 변경에 취약한 구조가 된다
  - IoC는 객체의 제어권을 컨테이너에게 위임한다.
  - 객체를 생성하고 관리하며 의존 객체를 연결하는 역할을 프레임워크가 수행한다
 
- IoC 컨테이너
  - IoC를 구현한 구체적인 프레임워크
  - IoC 컨테이너를 사용하면 객체의 생성, 초기화, 의존성 처리 등을 자동으로 수행할 수 있다.
  - 대표적으로 ApplicationContext가 있다.
 
  - Spring IoC 컨테이너
    - ApplicationContext를 가장 많이 씀
    - BeanFactory도 IoC 컨테이너로 동작함
    - Spring IoC 컨테이너의 주 역할 - **빈 객체들을 생성, 관리, 설정, 소멸까지 전 생명주기를 책임지는 것**
  - Bean
    - IoC 컨테이너가 관리하는 객체
    - 실제 애플리케이션 로직을 수행하는 객체(POJO)를 의미
  - BeanFacotory
    - Bean을 생성하고 반환하는 기능만을 제공
    - 초기에만 사용, 현재는 거의 사용 안함
    - 게으른 초기화 지원
  - Configuration Meatadata
    - IoC 컨테이너가 어떤 객체를, 어떻게 생성하고, 어떤 의존성을 주입해야 하는지에 대한 정보
    - 설정 방법
      - XML기반 (지양) / 명시적이지만 번거롭고 타입 안전성 부족
      - Java Config (@Configuration) (지향) / 명시적이고 타입 안전성 확보, Spring Boot 기본
      - Annotation 기반 (@Component) (보완적으로 추천) / Java Config와 함께 쓰면 효과적
  - ApplicationContext
    - BeanFactory(ListableBeanFactory) + ApplicationEventPublisher + MessageSourcec + ResourceLoader
    - ApplicationEventPublisher / 이벤트 처리 기능 제공
    - MessageSource  / 국제화를 지원하는 메세지를 해결하는 부가 기능 제공 ( 다국어 처리 )
    - ResourceLoader / 리소스 핸들링 기능 제공
   
  - Bean 생명주기
    - 빈 정의 로딩
      - 메타정보를 읽어들임 / 구성에 필요한 모든 정보
    - 객체 인스턴스 생성
      - new 키워드를 통해 빈 클래스의 객체 생성
    - 의존성 주입
      - 빈이 필요로 하는 다른 빈들을 주입
      - 주입 방식 : ***생성자***, 세터, 필드 기반
    - 초기화 콜백 실행
      - 빈 초기화 로직 정의 가능
      - @PostConstruct 애너테이션을 붙인 메서드
      - InitializingBean 인터페이스의 afterPropertieSet() 메서드
    - 사용
    - 소멸 콜백 실행
      - @PreDestroy 애너테이션을 붙인 메서드
      - DisposableBean 인터페이스의 destroy()메서드
  - 실무적 이점
    - 객체 간 결합도를 낮춤
    - 변경 가능성과 확장성 향상
    - 테스트 환경 분리 용이
    - 설정 방식 유연 (XML, JAVA CONFIG, ANNOTATION ...)

#### Framework / Librury
- Framework는 종속됨 / lib는 작은 기능을 개발 해 둔 것 (가져다 쓰는게 자유로움 / 쓸수도 안쓸수도 있음)
  - 제어가 프레임워크 vs 개발자

---

#### Bean
**Spring IoC 컨테이너-+-에 의해 관리되는 객체를 의미**
- 등록 방법
  - XML / JAVA CONFIG / ANNOTATION CONFIG
- 범위(Scope)
  - singleton ( default ) 단일 인스턴스
  - prototype 요청 시 마다 새로운 인스턴스 생성
  - request HTTP 요청마다 인스턴스 생성 (WEB CONTEXT)
  - session HTTP 세션마다 인스턴스 생성 (Web Context)
- 모든 Bean은 POJO 지만 모든 POJO가 Bean은 아니다

#### DI
의존성 : 어떤 객체가 다른 객체를 사용할 때 발생하는 관계

- 의존성 주입이 필요한 이유
  - 결합도를 낮춰줌
  - 유연성과 확장성 확보
  - 테스트 용이성 상승

- 의존성 주입
  - Controller - 클라이언트의 요청을 받는 엔드포인트 역할
  - > 클라이언트 측면에서 서버의 엔드포인트 : 클라이언트가 서버의 자원(리소스)을 이용하기 위한 끝 지점을 의미
  - 사용하고자 하는 클래스의 **객체를 생성해서 참조하게 되면 의존 관계가 성립**하게 된다
  - 생성자를 통해서 어떤 클래스의 객체를 전달받는 것을 **의존성 주입** 이라고 한다
  - > **생성자의 파라미터로 객체를 전달하는 것을 외부에서 객체를 주입한다** 라고 표현

- 의존성 주입의 필요성
- new 키워드를 쓸지 말지 여부를 결정하는 것
- new 키워드를 사용해서 객체를 생성하게 되면 참조할 클래스가 바뀌게 될 경우, 이 클래스를 사용하는 모든 클래스들을 수정해야 한다
- new 키워드를 사용해서 의존 객체를 생성할 때, 클래스 들 간에 강하게 결합되어 있다고 한다
- 느슨한 결합 필요
- DI 방식
  - **생성자 주입** / final 사용 가능
  - 필드 주입
  - 세터 주입
 
#### AOP
**시스템을 설계 하다 보면 모든 모듈에서 반복적으로 등장하는 로직들이 존재** ex) 로깅, 트랜잭션 처리, 보안 검사, 실행시간 측정<br>
이러한 코드들은 여러 클래스에 분산되어 반복되기 쉽다 -> OOP의 한계
- **핵심 비즈니스 로직과는 별개인 공통 기능**(횡단 관심사)을 하나의 모듈(Aspect)로 분리하여 관리 ( 관심사의 분리 )
- 횡단 관심사
  - 여러 계층 또는 컴포넌트에 걸쳐 반복적으로 나타나는 관심사
  - 각 클래스에서 직접 처리 시 중복을 유발하고 코드 유지보수성을 크게 떨어트림
  - AOP 적용 후 핵심 로직과 부가 로직을 완전히 분리 가능
- 활용방식
  - @AspectJ 스타일의 AOP 지원 / AspectJ 전체 기능 중 프록시 기반 AOP를 기본 제공
  - 스프림 프레임워크 AOP 특징
    - 프록시 기반 AOP 구현체 / 대상 객체에 대한 프록시를 만들어 제공 , 서버 RUNTIME 시 생성
    - **메서드 조인 포인트만 제공** / 핵심기능(대상 객체)의 메소드가 호출되는 런타임 시점에만 부가기능 적용
   
- 핵심구성 요소
  - 공통 관심 사항에 대한 기능을 애스팩트(Aspect)라고 한다
  - 어드바이스 : 공통 기능과 적용 시점을 정의한 것
  - 포인트 컷 : 어드바이스가 적용될 지점을 정의하는 것

  - 애즈팩트 : 공통 기능이 정의된 모듈 / 별도의 횡단 관심사
  - 조인 포인트 : 어드바이스가 적용 가능한 지점 / **메서드 호출 시점**
  - 어드바이스 : 실행될 공통 기능
    - 어노테이션으로 시점 결정 / @Before, @After, @Around, @AfterReturning, @AfterThrowing ...
  - 포인트 컷 : 조인 포인트 중, 어드바이스를 적용할 가능성이 있는 대상을 선별한 것 (후보군)
    - 주로 표현식을 사용해 선별 (SQL)
  - 위빙 : 어드바이스를 핵심 비즈니스 로직에 적용하는 것
 
- ***호출된 @Transectional 메서드와 동일 클래스 내부에서 다른 @Transectional 메서드를 호출 할 시 AOP 적용 X***
  - 다른 클래스로 위임 필요
 
## SPRING Framework
- 특징
  - 오픈 소스
  - Java 엔터프라이즈 애플리케이션을 쉽게 만들 수 있다
  - 프레임워크의 기본 원칙에 충실하다
    - 이전 버전과의 강력한 호환성 유지
    - 다양한 관점에서 다양한 애플리케이션 요구사항을 지원
    - 모든 수준에서 선택권 제공 
- 역할
  - IoC 컨테이너 : Bean 등록/생성/주입/소멸 전 생명주기 관리
  - AOP 엔진 : 공통 기능 분리를 위한 프록시 기반 AOP 제공
  - **MVC 프레임워크 (프론트 컨트롤러) : DispatcherServlet 기반의 요청 처리 흐름 구성**
  - 트랜잭션 추상화 : DB, JMS 등 다양한 자원에 대한 통합 트랜잭션 관리
 
- 기술적 적용 범위
  - 웹 애플리케이션 : Spring MVC 기반 REST API (CSR), 웹 페이지 서버 개발 (SSR)
  - 백엔드 API : 비즈니스 로직 중심의 ***RESTful*** 서비스 개발
  - 배치 처리 시스템 ( 큰 범위의 스케쥴링 )-
  - 마이크로서비스 기반 아키텍처
 
#### Spring Data
다양한 데이터 저장소에 대해 일관된 프로그래밍 모델과 추상화된 접근 방식을 제공하는 프로젝트 <br>
데이터 접근 로직의 생산성과 일관성을 획기적으로 향상
- Spring Data JPA : JPA 기반 ORM 추상화
- Spring Data MongoDB, Redis, Cassandra 등 NoSQL 지원
- Spring Data Elasticsearch 검색 엔진 연동
- Spring Data REST : Repo를 REST API로 자동 노출

- 특징
  - CRUD 코드 자동 생성
    - 메서드 이름만으로 쿼리 메서드 자동 구현
    - findByNameAndAge() 등 자연어 기반 선언
  - 공통 인터페이스 표준화
    - CrudRepository, JpaRepository 등 확장 기반 개발 / 이를 상속해서 crud 코드 자동 생성
  - 데이터 저장소 독립성 확보
    - 코드를 거의 변경하지 않고 데이터 저장소 교체 가능
  - 페이징, 정렬, 동적 쿼리, Auditing 등 다양한 부가기능 내장
 
#### Spring Security
인증과 인가를 담당하는 보안 프레임워크 <br>
**웹/API 보안 전반에 필요한 기능을 포괄적으로 제공**
- 특징
  - 인증/인가 분리 구조 제공
    - 인증 : 로그인, 세션, 토큰
    - 인가 : 권한 확인, 접근 제어
  - 세션 기반, 토큰 기반(JWT), OAuth2 등 다양한 인증 방식 지원
  - 필터 체인 기반 보안 처리
  - 선언적 메서드 보안기능
  - 보안 취약점 대응
 
#### Spring Cloud
마이크로서비스 아키텍처(MSA)를 위한 인프라 구성 요소를 통합 지원하는 프로젝트 <br>
복잡한 분산 시스템에서 자주 필요한 패턴을 구현하기 위한 구성서버, 서비스 디스커버리, 로드 밸런싱, API Gateway 등을 손쉽게 구성하게 도와줌
- 특징
  - 구성 서버
  - 서비스 디스커버리
  - API Gateway
  - 로깅/모니터링
  - 회복력 패턴 지원

#### 프로젝트 조합
- 각 프로젝트는 서로 독립적으로 사용 가능하면서 Spring Framework를 공통 기반으로 유기적으로 연결 가능
- Spring boot + Spring data
- Spring boot + Spring Security
- Spring boot + Spring Cloud
- Spring boot + Spring AOP
- Spring MVC + Spring Security + Spring Data JPA
- ...

---

## Spring boot
기존 Spring Framework가 갖고 있던 진입 장벽을 혁신적으로 낮춘 '발전형 프로젝트'
- 초기 spring framework 문제점
  - XML 설정 파일의 과도한 양
  - 환경 구성의 일관성 부족
  - 프로젝트 시작에 필요한 설정 정보를 모두 직접 수작업으로 구성해야 함
 
- 마이크로서비스 아키텍처의 부상
  - 변화된 요구 (기술 트렌드)
    - 단일 모놀리식 시스템 -> **작고 독립된 서비스 단위**로 분리
  - MSA와 Spring Boot의 상성
 
- 핵심가치
  - 자동 설정
    - 기능을 쓸 때마다 관련 설정을 수동으로 작성해야 했었다
    - 프로젝트 구성 및 설정에 일관성이 유지될 수 없었고, 실수 가능성이 높았다
    - -> 알아서 적절한 Bean 구성과 환경 설정을 자동으로 수행
    - > 개발자는 핵심 도메인 로직에만 집중 가능
      > 설정 실수로 인한 런타임 오류 대폭 감소
      > 일관성 있는 프로젝트 구조 유지 가능
  - 독립 실행 가능한 애플리케이션
    - was 설치, application 배포, was 실행의 .war파일의 복잡한 프로세스
    - -> 실행 가능한 jar 패키지로 배포와 실행을 통합
  - 내장 서버
    - was 수동 설치 및 구성 필요
    - 서버마다 설정 방식, 배포 방식이 달라 환경 종속성 존재
    - -> 내장 서버를 자동으로 포함

---

#### Spring Initializr
Spring 공식 사이트에서 제공하는 Spring Boot 프로젝트 생성 전용 웹 인터페이스
- [Spring Initializr](start.spring.io)

#### 프로젝트
- group : 보통 도메인 또는 조직명을 반대로 쓴 형태 (com.ohgiraffers.abc)
- artifact : 해당 프로젝트의 이름 또는 주요 기능명을 의미
- 패키징
  - jar (표준)
    - 실행 가능한 단일 jar파일 생성 -> java -jar로 실행 가능
  - war (전통)
    - 외부 was에 배포 필요
    - 일부 레거시 시스템과의 연동이 필요한 경우
  - ear (사용안함/과거에 war,jar 통합 관리 시)
- 기본 의존성
  - spring-boot-starter
    - 기본 구성요소 포함
    - 필수적인 기본 환경 구성
  - spring-boot-starter-test
    - 통합 테스트 툴 세트
   
  - fat jar
    - 프로젝트 코드 + 모든 의존성 라이브러리 + 설정 파일 + 리소스 + 내장 웹 서버를 하나의 JAR 파일로 패키징한 실행 가능한 단일 파일

- 모듈
  - spring-core
    - spring의 가장 기반이 되는 모듈
    - 유틸리티, 리플렉션, 타입 변환, 컬렉션 유틸, 예외 처리 등 핵심 기능 제공
    - 다른 모든 Spring 모듈의 공통 기반
   
  - spring-beans
    - DI 메커니즘의 중심
    - @Component, @Bean, ApplicationContext 등과 관련
    - *spring-core* 위에 구축됨
   
  - spring-context
    - 전체 컨테이너 환경 제공 : bean등록, 이벤트 발행 ,메시지 리소스 처리 등
    - ApplicationContext의 구현체들과 관련된 모든 기능을 제공
    - spring boot, MVC 환경에서 환경 구성의 중심축
    - *spring-core, spring-beans*에 의존
   
  - spring-web
    - 웹 기능의 기반 계층
    - spring-beans, spring-core에 의존                                                                                         
