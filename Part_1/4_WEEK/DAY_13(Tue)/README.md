# DAY_13

- [자료구조 선택가이드](#자료구조-선택가이드)
- [정렬 알고리즘](#정렬-알고리즘)
- [탐색 알고리즘](#탐색-알고리즘)

---

## 자료구조 선택가이드
#### 데이터 크기 별 권장 자료구조
- 소규모 데이터 ( n <= 100 )
  - 속도보다는 코드 간결성과 가독성 중요
  - ArrayList, LinkedList, Stack 등 단순 구조 사용
- 중간 규모 데이터 ( 수천 ~ 수만 건 )
  - 연산의 특성 ( 탐색 VS (중간)삽입/삭제 VS 정렬) 에 따라 선택
  - 정렬이 필요하다면 TreeMap, TreeSet
  - 빠른 탐색이 중요하면 HashMap, HashSet
- 대용량 데이터 ( 수십만, 수백만 건 이상 )
  - 시간/공간 복잡도 고려 필수
  - 메모리 효율성도 고려해야 하므로 ArrayList 선호 / 조회가 빈번함
  - 해시 기반 구조는 충돌 가능성, 정렬 구조는 트리 비용 고려

#### 연산 패턴별 권장 자료구조
- 조회가 많고, 삽입/삭제가 적은 경우
  - ArrayList, HashMap
- 삽입/삭제가 잦고 위치가 중요한 경우
  - LinkedList, Deque
- 우선순위를 기반 처리해야 하는 경우
  - PriorityQueue(우선순위 큐)
- 정렬된 데이터가 필요한 경우
  - Tree / TreeSet, TreeMap / (Red-Black Tree)
- 중복제거
  - HashSet
- (옵션) 키워드 자동완성, 접두사 검색
  - Trie
 
#### 메모리 제약 상황
- 고정된 크기, 반복 사용
  - 배열(Array)
  - 메모리 낭비가 적고, 예측 가능한 성능
- 중복 연산 피하기 위한 캐시
  - LinkedHashMap + LRU 정책 -> 캐시 구현 방식
- 스트리밍 방식
  - 전체를 저장하지 않고 한번씩만 처리

---

## 정렬 알고리즘
안정적인 정렬 -> 정렬이 불가능한 같은 값의 앞은 원래 앞에 있던 값이 차지하는 것<br>
안정적이지 않은 정렬 (non stable sort) 퀵,힙,선택
#### O(n^2)
- 두 요소를 비교하며 정렬하는 비교 기반 알고리즘
- 중첩 반복문으로 구현되
- **버블 정렬**
  - 서로 인접한 두 원소를 비교해 **큰 값을 뒤로 계속 밀어내는** 방식
  - 구현이 매우 단순 -> 비효율적
- **선택 정렬**
  - 남은 데이터 중에서 가장 작은 값을 찾아 **앞으로 이동**시키는 방식
  - 교환 횟수가 적음 (최대 n-1회)
  - 항상 n^2만큼 비교
  - 교환 비용일 클때 활용 ( 파일 입출력 기반 정렬 )
- **삽입 정렬**
  - 앞부분은 정렬된 상태로 유지하며, 새로운 요소를 적절한 위치에 삽입
  - 이미 정렬된 데이터에 매우 빠름 O(n)
  - 일반적으로 O(n^2)
  - 소규모 배열, 또는 정렬된 상태에 가까운 데이터에 활용

#### O(n log n)
- 실제로 널리 사용됨
- 분할 정복 방식이 특징 / 입력을 분할하고 재귀적으로 처리
- **퀵 정렬**
  - 기준을 정해, 작은 값과 큰 값을 양쪽으로 분류하고 이를 반복해 정렬
  - 안정적이지 않은 정렬 / 정렬을 보장하지 않음
  - 평균 O(n log n) 최악의 경우 O(n^2)
  - 공간 복잡도 O(log n) 스택 공간
- **병합 정렬**
  - 분할 정복 방식을 사용해 데이터를 절반씩 분할하고, 분할된 집합을 정렬해서 다시 병합
  - 절반씩 분할하면서 더이상 분할이 불가능할 때 병합하면서 정렬
  - 성능이 안정적 / 최악의 경우에도 O(n log n)
  - 공간복잡도 O(n) 보조배열 필요
- 힙 정렬
  - 데이터를 힙 구조로 구성 -> 최댓값/최소값을 반복적으로 꺼내 정렬
  - 최대값 힙 정렬과 최소값 힙 정렬 / 루트가 최대값이냐 최소값이냐
  - 힙 트리 구현 필요
  - 병합/퀵 정렬보다 느릴 수 있음 (O(n log n)이긴 한데 느릴 수 있음)
  - 공간복잡도 O(1) 추가 메모리 없이 정렬 가능
 - TimSort
   - python에서 사용하려고 개발 -> 자바에서도 사용 / 자바 = 퀵정렬&팀소트
   - merge(병합) + insertion(삽입)
   - 최선 O(n) 평균,최악 O(n log n)
   - 정렬되어 있는 곳에만 삽입 정렬 사용 , 다른 곳 병합 정렬 사용
- 객체 = TimSort , 원시자료 = 퀵 정렬

#### 특이한 정렬
- 계수 정렬
  - 작은 범위의 값들에 대해서 각 값의 등장 횟수를 세고, 그 정보를 바탕으로 정렬하는 방식
  - 시간 복잡도 O(n+k) n : 입력데이터 개수, k : 데이터 값의 범위 (ex:0~100)
  - 정수만 가능 / 값의 범위가 크면 메모리 낭비가 심함
- 기수 정렬
  - 각 숫자를 자릿수 별로 나누어 정렬 (LSD 방식: Least Significant Digit부터 정렬)
  - 정수, 문자열 등 고정된 구조 데이터에 빠름 / 자릿수 기반이라 정수, 문자열에 적합
  - 문자(아스키코드 기반) 일 때 많이 사용
 
---

## 탐색 알고리즘
- 선형 탐색 O(n)
  - 모든 요소를 처음부터 끝까지 하나씩 확인하는 방식 ( loop )
  - **정렬 여부 무관**
  - 소규모 데이터 / 정렬되지 않은 배열
 
- 이진 탐색 O(log n)
  - **정렬된 배열**에서 중앙 값을 기준으로 **절반씩** 좁혀가는 방식
  - 배열이 **정렬되어 있어야** 사용 가능
  - **중복이 없어야 함**
 
- 해시 기반 탐색 O(1)
  - 데이터를 키-값 쌍으로 저장한 뒤, 키를 통해 직접 접근하는 방식
  - 해시 충돌이 많을 경우 성능 저하
  - 평균 O(1) 최악 O(n) -> 모든 원소가 해시 충돌 시
  - 적절한 hashCode() 구현 필요
 
### 실무 권장
- 소규모
  - 삽입 정렬, 선택 정렬
  - 선형 탐색
 
- 중간 규모
  - 퀵정렬, 병합 정렬, Tim 정렬 O(n log n)
  - 이진 탐색(정렬 전제), 해시 기반 탐색
 
- 대용량
  - 힙 정렬, 계수 정렬(조건부)
  - 해시 기반, 인덱스 기반(ex: B-Tree)

- 정렬 데이터 이점
  - 탐색 속도 향상 (이진 탐색 가능)

- 자바 정렬
  - Arrays.sort()
    - 원시자료 = 퀵 sort
    - 객체 = TimSort
  - Collections.sort()
    - Arrays.sort() 호출 -> TimSort
    - 정렬 성능을 높이려면 Comparable 또는 Comparator를 잘 구현해야 함
