# DAY_33

## API 버전 관리
- 필요성
  - 요구사항 변화
  - 성능 개선 또는 내부 구조 변경
  - 기능 분리 혹은 통합
- 버전 관리 목표
  - 하위 호환성 유지 : 기존 클라이언트는 문제없이 계속 사용 가능
  - 점진적 전환 유도 : 새로운 기능은 신규 버전에서만 제공
  - API 문서화 용이 : 버전별로 명확한 기능 구분 가능
 
#### URI 기반 버전 관리
- URI 경로에 버전 정보를 포함시키는 전략
  - 버전마다 다른 Controller 클래스 분리
 
#### 헤더 기반 버전 관리
- HTTP 요청 헤더에 버전 정보를 포함시켜 API 버전 분기 방식
- 클라이언트 URI는 동일하게 유지하면서 헤더 값에 따라 버전 분기를 처리
- produces 속성을 통해 특정 미디어 타입 요청에 대해 각각의 메서드로 분기
- 사용자가 직접 테스트하기 어렵고 문서화 도구가 대응하기 어려울 수 있다. (문서화가 어렵다)

#### 호환성 유지 전략
- 하위 버전을 사용해도 대응이 가능해야 한다.
- Deprecated 표시 - 기존 버전을 계속 유지하되, 문서화로 전환 유도

## Spring REST Docs
- 테스트 코드 기반으로 문서를 자동으로 만들어주는 도구
  - 실제 API 요청과 응답을 기록하여 문서로 바꿔주기 때문에 신뢰도 높은 문서를 만들 수 있다.
  - 테스트가 필수 (TDD, Mockito)
  - 공공기관,금융사 등 문서 정확성이 중요한 환경
  - CI에서 자동 문서화를 구축하고자 하는 경우

## Swagger
- Swagger UI는 REST API 문서를 브라우저에서 시각화하고 테스트할 수 있는 도구
- SpringDoc OpenAPI는 Swagger 문서를 자동 생성해주는 라이브러리
- 그룹화와 태깅
  - 그룹 단위로 API 문서를 분할해서 관리할 수 있다.
  - API를 기능 단위로 묶어 정리하고 싶다면 Controller 클래스나 메서드에 @Tag를 붙인다.
- 요청/응답 예시 추가
  - @Schema : Dto에 필드에 설명 달기
  - @ApiResponse 메서드에 응답 예시
- 프론트와 협업이 많고 API 빠른 공유가 필요한 경우
- Try-it 버튼을 통한 UI 기반 실시간 테스트가 필요한 경우

## 문서화 표준 정립
- [기획/요구] -> [엔드포인트 정의] -> [문서화] -> [코드 리뷰] -> [문서 자동 생성 수동 pr] -> [문서배포]
- 기획 단계 : Notion, FigJam 등에서 명세 구상
- 엔드포인트 정의 : URI, 메서드, 스키마, status 코드 초안 수립
- Swagger or REST Docs 작업 분기 : 코드/테스트 수준에 따라 선택
- 코드 기반이기 때문에 코드를 업로드(github 등) 하면 문서 자동 최신화 가능
