# DAY_32

## 목차
- [응답 시간 모니터링](#응답-시간-모니터링)
- [에러처리 표준화](#에러처리-표준화)
- [사용량 체크 기능](#사용량-체크-기능)
- [품질 문서화](#품질-문서화)
  - [자주 쓰는 지표](#자주-쓰는-지표)
- [제한 사항 안내](#제한-사항-안내)
  - [대표 제한 항목](#대표-제한-항목)
- [모범 사례 제시](#모범-사례-제시)
- [REST 탄생 배경](#rest-탄생-배경)
  - [트래픽 증가 (한계)](#트래픽-증가-한계)
  - [REST 제안 배경](#rest-제안-배경)
  - [REST 6대 제약조건 개념도](#rest-6대-제약조건-개념도)
- [HTTP와 웹의 성공 요인](#http와-웹의-성공-요인)
- [REST 제약 조건](#rest-제약-조건)
  - [Client-Server 역할 분리](#client-server-역할-분리)
  - [Stateless 무상태성으로 수평 확장](#stateless-무상태성으로-수평-확장)
  - [Cacheable 네트워크 부하 감소](#cacheable-네트워크-부하-감소)
  - [Uniform Interface 일관성 있는 리소스 접근](#uniform-interface-일관성-있는-리소스-접근)
  - [Layered System 계층형 아키텍처](#layered-system-계층형-아키텍처)
- [Richardson 성숙도 모델](#richardson-성숙도-모델)
  - [제약조건 절충안](#제약조건-절충안)
- [API 설계 체크리스트](#api-설계-체크리스트)
- [Open API](#open-api)
  - [API Economy](#api-economy)
- [API-First 접근 방식](#api-first-접근-방식)
- [리소스 중심 URI 설계](#리소스-중심-uri-설계)
  - [URI 패턴 공식](#uri-패턴-공식)
  - [실무 컨벤션](#실무-컨벤션)
  - [리소스 모델링](#리소스-모델링)
  - [Query Parameter, Path Variable](#query-parameter-path-variable)
  - [리소스 식별자 설계 전략](#리소스-식별자-설계-전략)
- [HTTP 메서드 의미와 활용](#http-메서드-의미와-활용)
  - [멱등성](#멱등성)
  - [상태코드의 적절한 사용](#상태코드의-적절한-사용)
- [HTTP 헤더](#http-헤더)
- [API 응답 설계](#api-응답-설계)
- [RESTful API 기본](#restful-api-기본)
- [요청 처리](#요청-처리)
- [응답 처리](#응답-처리)
- [공통 예외 처리 @RestControllerAdvice](#공통-예외-처리-restcontrolleradvice)
  - [예외 핸들러 메서드](#예외-핸들러-메서드)
  - [ErrorResponse 클래스 확장](#errorresponse-클래스-확장)
- [연관 리소스 표현 방식 (응답 페이로드)](#연관-리소스-표현-방식-응답-페이로드)
- [HATEOAS](#hateoas)

## 응답 시간 모니터링
- AOP를 활용해 요청 처리 시간을 로그로 출력할 수 있다.
- Prometheus -> 데이터 수집
- Grafana -> 시각화 대시보드 제공
- 응답 시간 평균만 보는 것이 아니라 p95, p99 기준값으로 지연 구간 파악 필수

## 에러처리 표준화
- @ControllerAdvice와 @ExcpetionHandler를 조합하여 에러를 일관되게 처리할 수 있다
- @ControllerAdvice = 컨트롤러에서 발생하는 예외를 한 곳에 모아(일관되게) 처리할 수 있도록 작성한 클래스
- 에러메시지는 클라이언트 친화적 메시지 + 개발자용 상세 로그 분리해서 기록

## 사용량 체크 기능
- HandlerIntercepter
  - 핸들러 어뎁터 - 컨트롤러 사이에서 동작

## 품질 문서화
- SLO : 목표 수치
- P95/p99 : 95%, 99% 요청이 이 시간 안에 끝난다는 의미 (꼬리 지연 파악용)
- Error budget : SLO를 못 지켜도 되는 "오류 허용 시간". 월 43분 처럼 계산
- Rate Limit : 정해진 시간 동안 허용하는 최대 요청 수. 초과 시 429 오류
- RPS : 초당 처리할 수 있는 요청 수

#### 자주 쓰는 지표
- 평균 응답
- p95, p99
- 최대 처리량
- 가용성

Error Budget 계산법
- ( 1 - 가용성 목표) * 한 달(43 200 분)

- SLO를 정했다면 부하테스트(k6) 결과 그래프를 문서에 스크린샷으로 첨부
- "엑셀 대량 다운로드" 같이 예외적으로 느려질 API는 별도 문구로 예외 처리합니다.

## 제한 사항 안내
- 과도한 트래픽,오류 요청을 사전에 차단해 서버 자원을 보호
- 클라이언트가 무턱대고 파일 100MB를 보내지 않도록 가이드

#### 대표 제한 항목
- 최대 본문 길이 / 2MB / 413
- Rate Limit(IP) 분당 100건 / 429 + Retry-After:60
- 필드 길이 (title) 100자 / 400 FIELD_TOO_LONG
- 지원 타입 application/json / 415

## 모범 사례 제시
- 성공 사례 + 실패 사례
- 실패 사례는 여러개가 존재해야 함
  - 입력 검증 실패
  - 인증 토큰 만료
  - Rate Limit 초과
  - 서버 과부하 등

## REST 탄생 배경
#### 트래픽 증가 (한계)
- 상태를 서버에 증가 ( 세션 저장 )
  - 유지 전략 필요 (세션 동기화, 특정 세션이 저장되어 있는 서버에만 접근하도록)
- REST API가 토큰 인증 방식으로 무상태성을 유지하며 수평 확장을 가능하게 함

#### REST 제안 배경
- 웹이 빨리 퍼짐
- 어떤 아키텍처 제약이 웹의 확장성을 담보 했을까 -> 무상태성을 못 지킴
- 이 원리를 패턴으로 일반화 할 수 없을까?
- roy fielding 아키텍처 스타일의 제약조건을 정리함

#### REST 6대 제약조건 개념도
- Client-Server
- Stateless
- Cacheable
- Uniform Interface
  - 4가지 규칙
    - 모든 리소스는 고유한 URI로 식벼해야 함
    - 리소스는 JSON, XML 같은 표현 형태로 전달
    - 요청/응답 메시지는 자체 설명력을 가져야 함 (헤더, 상태코드, 콘텐츠 타입 포함)
    - 클라이언트가 서버로부터 받은 응답 내 링크를 통해 다음 행동 결정 (HATEOAS)
- Layered System
- Code-on-Demand

## HTTP와 웹의 성공 요인
- 단순성
  - 단 한 줄로 리소스를 요청할 수 있음
  - 개발 진입 장벽이 낮고, 모든 플랫폼에서 쉽게 구현 및 테스트가 가능
- 느슨한 결합
  - HTTP 메시지 하나만으로도 요청의 의도와 구조를 완전히 설명할 수 있음
  - 무엇을 요청하는지 명확
  - 서버 뿐 아니라 중간 프록시, 캐시 서버, API 게이트웨이도 이해하고 처리 가능
  - 하위 호환성
    - 기본 구조는 수십 년간 거의 바뀌지 않았음
- 캐시
  - 태생부터 캐시를 고려한 설계
  - 브라우저 - HTML,JS,이미지 등 / 사용자 체감 속도 증가
  - 프록시 서버 - 문서, 이미지, 공통 API / 대역폭 절감, 병목 지점 완화 = DB까지 안감
  - 정적 파일이 가장 적용이 쉬움 ( 불변 리소스 는 max-age를 길게 설정 )
  - 자주 변경되는 리소스는 no-cache, ETag 조합 사용
  - 보통 1분도 캐싱이 불가하면 불필요

## REST 제약 조건
#### Client-Server 역할 분리
- 관심사를 분리함으로 독립적인 개발과 배포 가능 / 결합도를 낮춤
- 추상화, 캡슐화(은닉), 수정사항이 다른 곳으로 전파 되지 않음

#### Stateless 무상태성으로 수평 확장
- 필요한 상태는 클라이언트가 매 요청마다 전달
- 서버가 상태를 저장하지 않기 떄문에 수평확장에 용이
- 사용자가 어떤 서버로 요청을 보내든 항상 동일한 결과를 얻을 수 있기 때문에 로드밸런서가 자유롭게 요청을 분산할 수 있음
- 서버를 재시작해도 세션이 끊기지 않는다.
- 요청에 필요한 정보만 제대로 포함되어 있으면, 서버는 언제든지 처리 가능.
- 로드밸런서를 사용할 때 Sticky Session 설정이 필요 없다.

#### Cachealbe 네트워크 부하 감소
- 서버 응답에는 반드시 캐시 가능 여부를 명시한다. -> 헤더에 포함
- 중간 계층이 응답을 저장,재사용할 수 있도록 한다.
- 변경되지 않았을 경우에만 캐싱 가능.

#### Uniform Interface 일관성 있는 리소스 접근
- URI = 자원 / HTTP Method = 행위
- 결합도를 낮추고, 확장성, 유지보수성을 높인다.
- URI와 메서드만 보고 어떤 기능을 하는지 알 수 있도록 하는 것이 BEST

- 4대 구성 규칙
  - URI 기반 식별
  - Representation 조작 / 리소스를 JSON 등으로 표현
  - Self-descriptive Messages / 요청/응답만으로 의미 파악 가능
  - HATEOAS / 응답 내 다음 행동 링크 제공
    - 클라이언트가 서버 응답 안의 링크 즉, 응답을 받은 클라이언트가 "이 다음엔 무엇을 할 수 있는가?"를 링크를 보고 판단할 수 있게 한다.
   
#### Layered System 계층형 아키텍처
- REST 시스템은 여러 계층으로 나눌 수 있는 구조를 기본 전제로 한다.
- 클라이언트는 중간 계층이 존재하더라도 최종 서버와 통신하는 것처럼 동작할 수 있다.
  - 인증, 로드밸런싱, 로깅, 캐싱 등을 거쳐도 최종 서버(MSA)와 통신하는 것처럼 보인다.
  - 별도의 계층을 분리하여 역할을 위임할 수 있다.

## Richardson 성숙도 모델
- Level 0
  - RPC 스타일, 하나의 엔드포인트 / HTTP 통신
  - 단순히 HTTP 프로토콜을 사용하는 것이 REST API의 출발 점
- Levle 1
  - 리소스 URI 사용
  - 모든 자원은 개별 리소스에 맞는 엔드포인트를 사용해야 한다
  - 요청하고 받은 자원에 대한 정보를 응답으로 전달해야 한다
  - 요청에 따른 응답으로 리소스를 전달할 때에도 사용한 리소스에 대한 정보와 함께 리소스 사용에 대한 성공/실패 여부를 반환해야 한다
- Level 2
  - HTTP 메서드 사용
  - CRUD에 맞게 적절한 HTTP 메서드를 사용하는 것에 중점
  - 응답 코드도 명확하게 작성해야 한다
  - 관련 리소스를 클라이언트가 Location 헤더에 작성된 URI를 통해 확인할 수 있도록 해야 한다
- Level 3
  - HATEOAS 포함
  - 추가적인 액션을 할 수 있는 링크를 함께 제공

#### 제약조건 절충안
- HATEOAS
  - 종적 링크 탐색 어려움
  - 링크 생략 + Swagger 문서로 대체
- Stateless
  - 로그인 후 사용자 상태를 계속 요구
  - ~~짧은 세션~~ or **JWT + Redis 혼합 전략**
  - 토큰만 가지고 로그아웃 구현 불가 -> 강제로 상태를 가지게 만든다(Redis)
- Cacheable
  - 실시간 데이터(주식, 채팅 등)에선 캐시 무용지물 (변화가 잦음, 실시간 통신 유지)
  - Cache-Control : no-store로 무효화
- Uniform Interface
  - 다양한 요청 요구사항으로 URI가 복잡해짐
  - GraphQL/BFF(Backend For Front-end)로 일부 대체
- Layered System
  - 디버깅이 계층을 넘어 복잡해짐
  - 트레이싱 도구 도입
- 플랫폼 별 대응
  - 모바일은 트래픽 절약용 압축,필드 축소 버전 -> 별도 BFF 도입 , 이미지 Lazy Load

#### API 설계 체크리스트
- 설계 전 판단 흐름
  - 비즈니스 범위 파악
  - 클라이언트 환경 확인
  - 데이터 특성 확인
  - 보안 요건 정리
  - REST 제약조건 준수 수준 결정
 
- 대표 설계 항목 & 선택지 비교
  - 버전관리 : 경로 기반 버전
  - 필터링
  - 페이징
  - 정렬
  - 에러 응답 : HTTP 상태 + 메시지
  - 응답 필드 제어 : 고정 DTO

- API 디자인 시 주요 고려 포인트
  - 응답 성능 : 쿼리는 JPA가 대신 해줌. BUT 집계의 경우 쿼리를 직접 쓰는게 성능면에서 좋음.
  - 요청 복잡도 : 이 경우 개발자가 쿼리문을 작성하는게 성능면에서 더 좋음.
  - 상태 변화
  - 인증 방식

- 트레이드오프 고려사항
  - 설계 완성도 REST 제약 완전 준수
    - 완성도 / 유지보수 용이, 표준화 ↑
    - 속도 / 진입장벽 ↑, 개발 속도 ↓
  - 개발 속도 빠른 결과 도출
    - 완성도 / 피처 릴리즈 빠름
    - 속도 / 구조 비일관, 기술부채 ↑
  - 이해도 & 학습비용 팀 내 공통 이해 수준
    - 완성도 / 학습 시간 ↑, 유지보수 안정성 ↑
    - 속도 / 신규 멤버 적응 어려움

## Open API
- 공개 API, 외부 개발자 또는 제휴사에게 공개된 API
- 누구나 문서를 참고하여 데이터를 요청하거나 기능을 사용할 수 있또록 제공하는 서비스 인터페이스
- 보통 REST, GraphQL 형식으로 제공
- 인증 방식으로는 API Key, OAuth2 등이 일반적

#### API Economy
- 기업이 자산(데이터, 기능)을 API로 공개하여, 새로운 수익 모델과 비즈니스 협업 구조를 창출하는 전략
- 보안, 유연성, 확장성을 동시에 충족

## API-First 접근 방식
- 프론트엔드와 백엔드 개발을 시작하기 전에 먼저 API 스펙을 정의하고 공유하는 방식
- API 명세를 먼저 정의
  - 백엔드/프론트엔드 동시에 병렬로 개발 가능
- Swagger 기반 API 문서 자동화
  - 코드 기반 자동 생성
  - 어노테이션 기반, 개발자 입력 의존
  - 별도 테스트 연계 없음
  - API 설계 및 프론트 협업용
- REST Docs
  - 테스트 결과 기반 생성
  - 실제 API 호출 결과 기반 (정확도 높음)
  - MockMvc 테스트와 통합 가능
  - 배포 문서 및 QA/운영 문서 최적화

## 리소스 중심 URI 설계
- 리소스 : 고유한 URI로 식별되는 서버 측의 데이터 개체 또는 서비스 대상

#### URI 패턴 공식
- URI는 리소스 중심으로 구성, 계층적 구조와 일관된 네이밍이 중요
- 복수형 컬렉션 리소스
- 하위 컬렉션 (/상위/{id}/하위) (/orders/42/items 주문 42번의 아이템 목록)

#### 실무 컨벤션
- 리소스 네이밍 : 복수형 명사
- 소문자 사용
- 케밥 케이스 : 띄워쓰기는 -로 대체
- 슬래시 의미 : 계층 표현
- 동사 표현 금지 : HTTP 메서드로 대체

#### 리소스 모델링
- 계층형 URI
  - 하위 리소스가 상위 리소스의 컨텍스트에 종속되어 있을 때 사용
- 독립 URI 병행
  - 일부 하위 리소스는 독립적으로도 사용 가능
  - 계층 URI + 비계층 URI 병행

#### Query Parameter, Path Variable
- Query Parameter
  - 검색, 필터링, 정렬, 페이징 등 옵션성 조건
  - 주로 GET 메서드에 사용 (조회 목적)
- Path Variable
  - 고유 리소스의 식별자
  - 단일 객체 or 계층 구조 접근 시
 
#### 리소스 식별자 설계 전략
- RESTful API에서 각 리소스를 고유하게 식별하는 값
- slug
  - 글 제목이나 리소스 이름 등을 URL-Friendly한 문자열로 바꾼 값 / 사람이 읽기 쉬운 고유 식별자
- 식별자 유형
  - 숫자 기반 (PK)
    - 짧고 정렬 쉬움, 인덱스 효율적
    - 예측 가능, 노출 위험
  - UUID
    - 충돌 없음, 분산 환경 적합
    - 길이 36자, 인덱스 비효율
  - 자연키(Slug,Username)
  - HashID, base62

- 실무 설계
  - 내부 Db는 숫자PK, 외부 URI에는 UUID 또는 해시 ID 사용
  - 불변 식별자 사용
  - 정렬 고려 시 ~~Snowflake ID~~ 최근에는 UUIDv7
  - 노출 ID는 검색 가능하게 설계 /users/uuid 기반 검색을 고려한 인덱싱 필요
 
## HTTP 메서드 의미와 활용
#### GET
- 안전하고 멱등 한 조회
#### POST
- 새 리소스 생성
#### PUT
- 리소스 전체 수정 / 모든 필드를 대체할 때
- 없으면 생성하기도 함
#### PATCH
- 부분수정 / 일부 필드만 변경할 때
#### DELETE
- 리소스 삭제
#### 멱등성
- GET, PUT, DELETE

#### 상태코드의 적절한 사용
- 2xx 성공
  - 200 OK
  - 201 Created
    - 응답 시 Location 헤더에 새 리소스 URI 포함
  - 204 No Content
 
- 3xx 리다이렉트
  - 301 Moved Permanently 영구이동/ 다음부터는 /new-url로 바로 접근하게 됨
  - 302 found : 일시 이동 (로그인 후 리다이렉트) / 일시적으로 보내는 곳

- 4xx 클라이언트 오류
  - 400 Bad Request
  - 401 Unauthorized
  - 403 Forbidden
  - 404 Not Found 리소스 없음
  - 422 Unprocessable Entity 비즈니스 검증 실패

- 5xx 서버 오류
  - 500 Internal Server Error
  - 503 Service Unavailable 유지보수, 과부하
  - 504 Gateway Timeout 게이트웨이 서버 응답 불가 (시간 초과)

## HTTP 헤더
#### Content-Type/ Accept
- Content-Type : 요청 본문 타입
- Accept : 클라이언트가 원하는 응답 타입

#### Authorization
- 인증 토큰 전달

#### Cache-Control / ETag
- 캐싱 고급 활용
- 클라이언트 캐싱 전략 (헤더 기반)

## API 응답 설계
- 일관된 응답 구조
  - 기본 응답 포맷 { "success" = true # 있어도 그만 없어도 그만, "data" : {} # 업계 표준, "error":null}
  - {"success" : false, "data" :null, "error": {"code","message"...}
- 성격/실패 응답 형식
  - 성공이든 실패든 일관된 형태를 가지고 있어야 한다. / 일관되게 접근할 수 있어야 한다.

## RESTful API 기본
#### @RestController
- @Controller + @ResponseBody
- View가 아니라 JSON을 반환한다.

#### ResponseEntity
- HTTP 응답의 전체코드(상태 코드, 헤더, 바디)를 개발자가 직접 제어할 수 있도록 도와주는 스프링 클래스
- ResponseEntity<ResponseDto<UserDto>> = data에 일관되게 넣기 위해

#### MessageConverter
- 요청 본문을 자바 객체로 변환하거나, 자바 객체를 응답 본문으로 직렬화 할 때 사용하는 컴포넌트

## 요청 처리
#### @PathVariable
- URI 경로의 일부를 변수로 받아오는 어노테이션
- RESTful 스타일에서 리소스 식별자(ID)를 표현할 때 사용
- URI 템플릿(/users/{user-id})에 포함된 값을 자동 바인딩

- 흐름
  - DispatcherServlet
  - HandlerMapping
  - HandlerAdapter
  - HandlerMethodArgumentResolver

- PathVariable에 특수 문자가 포함될 수 있는 경우 -> URL 인코딩 필수 (URLEncoder.endcode())
- 리소스가 들기 때문에 특수문자, 한글이 포함되지 않도록 하는 것이 좋음
 
#### @RequestParam
- HTTP 요청의 쿼리 파라미터 또는 form-data를 컨트롤러 메서드 파라미터로 바인딩
- required, defaultValue, name 속성으로 제어 가능
- 여러 값이 전달될 경우 List<String> 또는 *MultiValueMap<String, String>* 사용 가능

#### @RequestBody 활용과 검증
- HTTP Body를 객체로 역직렬화 (JSON -> 객체)
- JSON 구조가 깊은 경우 -> 중첩 DTO 구조화로 복잡도 분리

## 응답 처리
- 일관된 응답 구조
  - 프론트엔드와의 예측 가능한 통신
  - 응답 결과에 대한 정형화된 처리 로직 구현
  - 응답 정보의 확장성과 유지보수성 확보
- JSON 어노테이션
  - JsonFormat (날짜 포맷 생성)
 
- 파일 다운로드
  - 파일 응답은 ResponseEntity<Resource> 형태로 반환, Content-Disposition을 반드시 지정해야 함.
 
- 상태코드, 헤더 커스터마이징
  - 상태코드를 잘 설정하면 추가적인 정보를 제공해 줄 수 있다. ( 로깅 없이 정보를 얻을 수 있음 )

```
public ResponseDto<T> {
  T data;
}
or
public ResponseDto<List<T>> {
  List<T> data;
}
```

## 공통 예외 처리 @RestControllerAdvice
#### @RestControllerAdvice
- 여러 컨트롤러에서 발생한 예외를 공통적으로 처리할 수 있는 클래스에 사용하는 어노테이션
- @ControllerAdvice + @ResponseBody
- 각각의 컨트롤러마다 @ExceptionHandler를 작성하면 중복 코드 증가, 유지 보수 어려움 등의 문제가 발생
- @ResponseStatus(HttpStatus.BAD_REQUEST) 로 일반 객체에 상태코드를 추가할 수 있음

#### 예외 핸들러 메서드
- 컨트롤러 진입 이전에 발생한 예외 처리
- DTO 검증 실패 예외 처리 (MethodArgumentNotValidException)
  - URI, HTTP Method가 정상적이지 않을 때
  - @Valid
- URI 변수 검증 실패 예외 처리 (ConstraintViolationException)
  - @PathVariable @Validated 예외

#### ErrorResponse 클래스 확장
- of() 메서드 / 정적 팩토리 메서드 패턴
  - Java에서 객체 생성을 명확하게 표현하는 대표적인 네이밍 컨벤션
  - 어떤 데이터로부터 ErrorResponse를 생성했는지 의도를 분명히 함

## 연관 리소스 표현 방식 (응답 페이로드)
#### 리소스 식별자 포함 (Reference 방식)
- 연관 리소스를 직접 포함하는 대신 ID만 제공하고, 필요 시 별도의 요청으로 상세 정보를 조회
- 응답이 가볍고 직관적, 응답 페이로드가 작아 성능에 유리
- 클라이언트에서 별도의 API 호출이 필요
- REST API 클라이언트에서 리스트 뷰 화면 등에서 빠르게 출력할 때
- 관계가 느슨하거나 상세 정보가 자주 필요하지 않은 경우

#### 리소스 임베딩 방식
- 연관 리소스의 상세 정보를 함께 응답에 포함시키는 방식
- 클라이언트가 추가 요청 없이 즉시 정보 사용 가능, 연관 정보에 대한 사용자 친화적 응답 제공
- 응답 크기 증가, 중첩 구조 복잡도 증가
- 상세 페이지에서 사용자의 주문과 관련된 상세 정보를 한 번에 보여 줄 때
- API Gateway 또는 BFF 구성에서 자주 사용

## HATEOAS
- 응답 안에 링크 정보를 포함시켜 클라이언트가 어떤 요청을 보낼 수 있는지를 안내하는 방식
- 기존에는 API 문서를 참고해야 다음 요청을 알 수 있지만 HATEOAS를 적용하면 응답 안의 링크만 따라가면 된다.
- 주요 구성 요소
  - EntityModel<T> : 1개일때
  - CollectionModel<T> : 여러개 일 때
