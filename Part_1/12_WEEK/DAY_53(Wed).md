# DAY_53

## 목차
- [애플리케이션 안정성](#애플리케이션-안정성)
- [안정성 확보 전략](#안정성-확보-전략)
- [예외 처리](#예외-처리)

## 애플리케이션 안정성
- 발생 가능한 문제
  - 잘못된 입력값 유입
  - 예상치 못한 예외 발생
  - 시스템 리소스 부족
  - 외부 시스템 연동 실패
 
#### 잘못된 입력값 유입
- 방치 시 발생하는 문제
  - 데이터베이스 무결성 훼손
  - 시스템 예외 발생
  - 비즈니스 로직 오류
  - 보안 위협 (SQL Injection, XSS 등)
 
- 잘못된 입력값 예시
  - 필수값 누락 : 이메일 주소가 null
  - 잘못된 형식 : 이메일 주소에 '@' 없음
  - 범위 초과 : 나이가 -1 또는 1000
  - 비즈니스 규칙 위반 : 종료일이 시작일보다 이전
 
- Validation 제공 어노테이션 사용하여 검증

#### 예상치 못한 예외 발생
- NullPointerException, IllegalArgumentException, IndexOutOfBoundsException, NoSuchElementException ...
- 런타임 오류 등

- 필요성
  - 모든 예외를 try-catch로 처리하면 코드가 복잡해짐
  - @ControllerAdvice와 @ExceptionHandler로 예외를 일관되게 관리

#### 시스템 리소스 부족
- 주요 리소스
  - DB Connection Pool
  - Memory (Heap/Stack)
  - Thread Pool
  - Disk I/O
 
- 발생 원인
  - 커넥션 반납 누락
  - 무한 루프 / 무한 재귀 호출
  - 대용량 데이터 캐시 누적
  - 비효율적인 알고리즘
 
- 예방 방법
  - try-with-resources 사용 (DB, File)
  - GC 튜닝 및 모니터링
  - 스레드 수 제한
  - 캐시 적정 유지
 
#### 외부 시스템 연동 실패
- 상대방 장애나 네트워크 이슈로 실패할 수 있음
- 발생 사례
  - 외부 API 타임아웃
  - 4xx, 5xx 에러
  - 인증 실패
  - 네트워크 단절
 
- 대응 방법
  - 예외 처리, 재시도 로직
  - Circuit Breaker 적용 (Resilience4j)
  - Fallback 대체 로직 제공
 
## 안정성 확보 전략
#### 예외 처리 전략
- 비정상 상황에 적절히 대응하는 시스템
- 필요성
  - 일관된 응답
  - 명확한 메시지
  - 빠른 디버깅   
- 주요 예외 처리 전략
  - @ControllerAdvice
  - 사용자 정의 예외
  - 적절한 HTTP 상태 코드 반환
  - 로깅 연계

#### 로징 전략
- 애플리케이션 동작 상태 기록
- 다음과 같은 질문에 답할 수 있어야 함
  - 언제, 어떤 요청이 들어왔는가?
  - 어떤 에러가 발생했는가?
  - 어떤 입력값으로 호출되었는가?
  - 어떤 경로를 통해 로직이 실행되었는가?
 
- 로깅 레벨
  - ERROR : 시스템에 치명적인 장애 발생 / DB연결 실패, NullPointerException 등
  - WARN : 예상은 했으나 조치가 필요한 경고 상황 / 인증 실패, 잘못된 입력값, 성능 저하 등
  - INFO : 정상적인 흐름 기록 (주요 이벤트) / 회원가입 성공, 주문 완료 등
  - DEBUG : 개발/테스트 단계에서 필요한 상세 정보 / 내부 상태, 변수 값, 흐름 추적 등
  - TRACE : 상세한 코드 흐름 추적 (거의 사용안함) / 모든 메서드 호출 흐름, 루프 등
 
#### 입력값 검증 전략
- 데이터가 신뢰할 수 있는 것인지 확인하는 과정
- 발생하는 문제
  - 데이터 무결성 훼손
  - 예기치 않은 예외 발생
  - 보안 위협
  - 잘못된 비즈니스 로직 수행
 
- 입력값 검증 위치와 역할
  - 클라이언트 : UX 개선, 빠른 피드백 제공 / HTML5 required, 자바스크립트 검사 등
  - 서버 : 최종 무결성 보장, 보안 강화 / spring @Valid, @Validated
  - @Valid, @Validated 활용
  - BindingResult로 유연하게 대응
  - 비즈니스 규칙은 별도 서비스 검증
 
#### 모니터링 전략
- 미리 상태를 확인하고, 문제가 생기면 빠르게 알아차릴 수 있도록
- 목표
  - 장애 조기 탐지
  - 성능 병목 지점 확인
  - 리소스 낭비 방지
  - 비즈니스 트렌드 분석
 
- 주요 모니터링 지표(KPI)
  - 응답시간 : 평균, P95, P99 (느린 요청 확인용)
  - 오류율 : 4xx, 5xx / 1% 넘어가면 빠른 대응 필용
  - 처리량 : TPS, RPS / 부하량 추이 분석, 용량 계획 필수
  - 리소스 사용량 : CPU, Memory, DB Connection 등
 
- 도구 및 활용 방법
  - Prometheus : 시계열 메트릭 수집 및 저장
  - Grafana : 시각화 대시보드, 경고 트리거
  - Spring Boot Actuator : JVM / 애플리케이션 상태 정보 제공
  - Micrometer / 다양한 모니터링 시스템 연동
 
- 알림 시스템 연계 예시
  - Slack / Email / SMS
  - 장애 발생 시 빠른 전파 (Slack Ops 채널 등)
 
## 예외 처리
- Spring Boot 계층 구조와 예외 처리 위치
  - Controller : 파라미터 검증 예외
  - Service : 비즈니스 로직 예외
  - Repository : DB connection 예외(잘못된 쿼리문)
  - Exception
  - 예외 처리는 ControllerAdvice, ExceptionHandler, Custom Exception 등을 활용하여 controller 계층에서 일괄적으로 관리
 
- 예외 발생 시 문제점
  - 서비스 중단
  - 사용자 경험 저하
  - 장애 추적 어려움
  - 보안 문제
 
- 기대효과
  - 안정적인 서비스 운영
  - 명확한 피드백
  - 장애 추적 용이
  - 보안 강화

## 예외 추상화
- 여러 기술의 예외를 일관된 방식으로 처리할 수 있게 함 (DataAccessException)
  - SQLException /  ersistenceException / HibernateException -> DataAccessException
- 서비스 계층에서는 기술 종속적인 예외 대신 Spring의 추상화된 예외만 다루는 것이 좋다.
  - 기술 교체 시에도 예외 처리 코드를 그대로 유지할 수 있어 유지보수성과 이식성이 향상된다.
  - 예외 메시지를 로그로 남기고 사용자에게는 추상화된 에러 메시지를 제공
 
#### 체크 언체크
- 체크
  - 반드시 처리 필요
  - IOException, SQLException
  - 주로 외부 자원 접근 시
  - 외부 시스템 오류에 대비하여 컴파일 시점에 강제 처리
 
- 언체크
  - 처리 선택 가능
  - NullPointerException, IllegalArgumentException
  - 내부 비즈니스 로직 검증, null 접근 등
  - 로직 오류는 개발자 책임이므로 유연하게 처리
 
- 나눠 처리하는 이유
  - 기술 종속성 제거
  - 비즈니스 로직 단순화
  - 예외 처리 일관성 확보
  - 관심사의 분리
 
#### 예외 변환 메커니즘
- 필요성 (문제점)
  - 기술 종속
  - 책임 분리 위반
  - 예외 처리 중복
  - 유지보수 어려움
 
## 예외 계층 구조 설계
- 계층적 설계 이점
  - 유지보수성 향상
  - 책임 분리
  - 사용자 경험 개선
 
