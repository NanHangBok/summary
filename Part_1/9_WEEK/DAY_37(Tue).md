# DAY_37

---
## 목차
- [SELECT](#select)
- [INSERT, UPDATE, DELETE](#데이터-변경)
  - [INSERT](#insert)
  - [UPDATE](#update)
  - [DELETE](#delete)
- [JOIN](#join)
- [GROUP BY](#집계와-그룹화)
- [데이터베이스 설계](#데이터베이스-설계)
- [데이터 모델링](#데이터-모델링)
- [데이터베이스 설계 프로세스](#데이터베이스-설계-프로세스)
- [주요 산출물](#주요-산출물)
- [요구사항 분석](#비즈니스-요구사항-분석)
- [데이터 사전](#데이터-사전)
- [개념적 모델링](#개념적-모델링)
  - [엔티티 도출](#엔티티-도출)
  - [관계 정의](#관계-정의)
  - [ERD](#erd)
- [논리적 모델링](#논리적-모델링)
  - [속성 정의와 설계](#속성-정의와-설계)
  - [식별자 설계](#식별자-설계)
  - [정규화](#정규화)

---

## SELECT

- DB 성능 최적화
  - 쿼리문 인덱스 추가
 
- ORDER BY
  - ```sql
    SELECT *
    FROM members
    ORDER BY age [ASC/DESC];
    -- 기본은 오름차순
    ```
  - ```sql
    SELECT *
    FROM members
    ORDER BY age DESC, name;
    -- 다중 정렬도 가능
    -- name 처럼 수가 아니어도 가능 (한글, 영어, 날짜 등)
    ```
  - SELECT에 컬럼이 포함되어 있어야 가능

- LIMIT, OFFSET / 페이징처리
  - LIMIT : 최대 조회 수 제한
  - 조회 성능 ↑
  - ```sql
    SELECT *
    FROM members
    LIMIT 5;
    ```
  - OFFSET : 몇번째부터 시작할 지 / 몇개를 건너뛰고 시작할 지
  - 데이터가 많으면 (너무나 많으면) 성능이 떨어질 수 있음 -> 인덱스 탐색이 더 효율적(Keyset 기반 페이징)
  - ```sql
    SELECT *
    FROM members
    LIMIT 5 OFFSET 5;
    ```

## 데이터 변경
#### INSERT
- 데이터 추가
- ```sql
  INSERT INTO members(name, phone, email, age)
  VALUES ('이름','010-1234-1234','email@example.com',20);
  ```
- members()에 지정한 삽입할 컬럼들과 VALUES에서 순서를 정확히 일치시켜야 함.
- ```sql
  INSERT INTO products (name)
  VALUES ('노트북'),
        ('스마트폰'),
        ('프린터');
  -- 다중 삽입 가능
  ```
- NOT NULL 제약 조건이 있는 컬럼은 반드시 값을 입력해야 한다.
- 기본 값이 있는 컬럼은 생략할 수 있다

#### UPDATE
- 데이터 수정
- ```sql
  UPDATE members
  SET phone = '010-9999-9999'
  WHERE member_id = 3;
  ```
- SET : 수정할 컬럼과 값을 지정
- WHERE 없이 UPDATE 하면 모든 행이 변경

##### DELETE
- 데이터 삭제
- ```sql
  DELETE FROM members
  WHERE member_id = 5;
  ```
- DELETE FROM : 삭제할 테이블 지정
- WHERE 없이 DELETE 하면 모든 행 삭제 -> 꼭 지정해야 안전함!
- 참조중인 다른 테이블이 있으면 삭제되지 않을 수 있음 / 테이블 설계 시 CASCADE 추가 시 참조하는 값들도 같이 삭제 됨

## JOIN
#### ANSI 표준 조인
- 테이블 간의 관계를 명시적으로 표현하는 표준 문법
- 기존의 암시적 조인(WHERE 조건 기반 조인)보다 가독성이 뛰어나고 유지보수에 강한 코드 작성이 가능
- 종류
  - INNER JOIN : 두 테이블 간의 일치하는 행만 결과에 포함
  - LEFT OUTER JOIN : 왼쪽 테이블은 모든 행 포함, 오른쪽 테이블은 일치 시 값, 없으면 NULL
  - RIGHT OUTER JOIN : 오른쪽 테이블은 모든 행 포함, 왼쪽 테이블은 일치 시 값, 없으면 NULL
  - ```sql
    SELECT 컬럼목록
    FROM 테이블1
    [INNER|LEFT OUTER|RIGHT OUTER|FULL OUTER] JOIN 테이블2
    ON 테이블1.기준컬럼 = 테이블2.기준컬럼;
    ```
  - ```sql
    SELECT *
    FROM members
    [INNER|LEFT OUTER|RIGHT OUTER|FULL OUTER] JOIN orders
    ON members.member_id = orders.member_id;
    ```
  - INNER JOIN : member_id가 양쪽 테이블에 모두 존재할 때만 결과 반환 / JOIN만 사용 시 INNER JOIN으로 표현 됨
  - LEFT OUTER JOIN : 왼쪽(테이블1/members)의 member_id를 모두 가져오고 orders에 있으면 값을 없으면 null
  - RIGHT OUTER JOIN : 오른쪽(테이블2/orders)의 member_id를 모두 가져오고 members에 있으면 값을 없으면 null
- 별칭 AS
  - 긴 테이블 명을 별칭을 추가해서 짧게 표현 가능
  - AS 생략 가능 (일부 불가능 할수도 있음)
  - ```sql
    SELECT *
    FROM members AS m
    JOIN orders AS o
    ON m.member_id = o.member_id;
    ```
- 다중 테이블 JOIN
  - ```sql
    SELECT m.name, p.name, oi.quantity
    FROM members AS m
    JOIN orders AS o ON m.member_id = o.member_id
    JOIN order_items AS oi ON o.order_id = oi.order_id
    JOIN products AS p ON oi.product_id = p.product_id;
    -- 상품 주문자와 상품의 이름, 개수를 조회
    ```

## 집계와 그룹화
- JPA에서 해주긴 하나 성능이 떨어짐
- 개발자가 직접 쿼리를 사용
#### GROUP BY
- 집계함수 (COUNT, SUM, AVG, MAX, MIN...)를 사용하기 위해 특정 컬럼을 기준으로 행을 그룹화
- HAVING
  - **WHERE은 집계 이전 조건, HAVING은 집계 이후 조건 필터링**
  - **집계함수 이후에 집계함수로 조건 필터링 하고 싶을 경우 사용**
  - WHERE = age >= 20 /20살 이상
  - HAVING = COUNT(*) >= 2 / 2개 이상
- COUNT(*) 전체 행 수
- COUNT(column(ex:name,phone,email...)) null 제외 행 수
- 그룹화에 묶을 수 없는 컬럼은 SELECT에 포함될 수 없음 ex) GROUP BY name일 때, SELECT name, email 불가
  - 동명이인을 하나로 묶었지만 동명이인이 동일한 email을 사용하지 않으므로 어떤 email을 표시해야 할 지 알 수 없음

## 데이터베이스 설계
- 중요성
  - 비즈니스 로직의 핵심을 반영하고 시스템의 일관성과 성능을 보장하는 근간
- 데이터 중복과 불일치 방지
  - ```sql
    -- 잘못 설계된 주문 테이블 예시
    CREATE TABLE orders (
        order_id SERIAL PRIMARY KEY,
        customer_name VARCHAR(100),
        customer_email VARCHAR(100),
        customer_address TEXT,
        product_name VARCHAR(100),
        order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    ```
  - 개선된 설계
  - ```sql
    -- 고객 테이블
    CREATE TABLE customers (
        customer_id SERIAL PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        address TEXT
    );
    
    -- 주문 테이블 (고객 ID 참조)
    CREATE TABLE orders (
        order_id SERIAL PRIMARY KEY,
        customer_id INTEGER NOT NULL,
        product_name VARCHAR(100),
        order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
    );
    ```
- 데이터 정합성과 일관성 보장
  - 정합성이란 논리적으로 모순 없는 데이터를 의미
  - 불필요한 중복 뿐 아니라 제약조건과 트랜잭션 처리를 통해 정합성 유지
  - 제약조건(CHECK, NOT NULL, UNIQUE 등) 활용
- 효율적인 데이터 접근과 관리
  - 빠르고 효율적인 검색, 수정, 확장성까지 고려해야 한다.
  - 조회 성능을 고려한 비정규화 전략도 있음
  - 보편적으로 UNIQUE 제약조건을 추가하면 인덱스도 같이 추가 됨

## 데이터 모델링
- 현실 세계의 데이터를 구조화하여 시스템에서 처리 가능한 형태로 추상화하는 작업
- 현실에서 벌어지는 일들을 데이터베이스로 논리적, 구조적으로 표현하는 설계 과정
- 구성 요소
  - 엔티티 : 독립적으로 존재할 수 있는 객체 또는 개념 / 회원, 주문, 상품 / 테이블 명
  - 속성 : 엔티티가 가지는 고유한 성질 / 이름, 이메일, 가격 / 테이블 내 속성(컬럼)
  - 관계 : 두 개 이상의 엔티티 간의 연결 / 회원-주문 / 의존관계

- 필요 이유
  - 추상화
  - 단순화
  - 명확화
 
- 모델링 단계
  - 현실 세계
  - 개념적 모델 / 특징 정의
  - 논리/물리 모델 / 데이터베이스에서 표현

## 데이터베이스 설계 프로세스
- 현실 세계의 정보를 체계적이고 일관성 있게 표현한 구조
- 요구사항 분석 -> 개념 데이터 모델링 -> 논리 데이터 모델링 -> 물리 데이터 모델링
#### 요구사항 분석
- 시스템에서 어떤 데이터를 다루어야 하는지 파악
- 주요 엔티티(개체), 행위, 규칙을 추출
- 주요 산출물
  - 엔티티 목록
  - 속성 목록
  - 관계 도출 (1:1, 1:n, n:m)
 
#### 개념적 모델링
- 사용자 관점에서 **전체 데이터 구조를 시각적으로 표현**
- ERD를 통해 엔티티, 속성, 관계 정의
- 주요 산출물
  - ERD : 엔티티 간 관계를 시각적으로 표현
  - 정의서 : 각 엔티티, 속성, 관계에 대한 설명 포함

#### 논리적 모델링
- DBMS 독립적으로 정규화된 관계형 구조 도출
- PK, FK, 제약조건 등을 명확히 설정
- DB에 넣을 수 있는 형태의 설계
- 주요 산출물
  - 스키마 정의서 : 테이블, 컬럼, 데이터 타입 정의
  - 정규화 표 : 1NF~3NF까지 정규화 여부 명시
  - 제약조건 목록

#### 물리적 모델링
- 특정 DBMS 에 맞춰 실제 스키마 구현
- 인덱스, 파티셔닝, 스토리지 용량 등 성능 요소 반영
- 주요 고려 사항
  - 인덱스 : 자주 조회/조인되는 컬럼에 적용
  - 파티셔닝 : 대용량 테이블을 범위별 분할
  - 테이블스페이스 : 물리 저장소 분산 고려
 
## 주요 산출물
- 요구사항 정의서
  - 시스템에서 사용자 또는 이해관계자의 요구를 분석하여 문서화한 결과물
  - 주로 비즈니스 규칙, 기능 요건, 비기능 요건 등을 포함
- ERD
  - 현실 세계의 객체(엔티티)와 그들 간의 관계를 시각적으로 표현한 다이어그램
  - 데이터 구조를 논리적으로 설계하기 위한 기초 도구
- 논리 데이터 모델
  - ERD를 기반으로 실제 RDB에 적합하도록 테이블 구조를 논리적으로 정제한 모델
  - 정규화, 속성 타입, 제약 조건 등을 정의 함
  - 테이블 명, 컬럼, 제약 조건 등 산출
- 물리 데이터 모델과 DDL
  - 논리 모델을 기반으로 실제 DBMS에 배포 가능한 구조로 변환
  - DDL을 통해 테이블, 인덱스, 제약조건 등을 생성
 
- 모델링은 반복적인 과저이며, 요구사항 변화에 따라 수정되는 것을 전제로 설계해야 한다.
- 정규화는 너무 과하게 하면 성능에 영향을 줄 수 있음 -> 역정규화도 고려

## 비즈니스 요구사항 분석
- 비즈니스 요구사항 분석
  - 기능적 요구사항
    - 사용가자 원하는 기능, 서비스
    - 시스템이 무엇을 해야 하는가
  - 비기능적 요구사항
    - 성능, 보안, 안정성 등 기능 외적인 요구사항
- 데이터 관련 요구사항 도출
  - 어떤 정보를 저장해야 하는지 판단
- 제약조건 파악
  - 데이터 무결성을 위한 중요한 장치
 
## 데이터 사전
- 데이터베이스에 저장되는 모든 데이터 항목에 대한 정의, 형식, 제약조건 등 메타정보를 체계적으로 정리한 문서

#### 작성 단계
- 용어 표준화 및 명명 규칙
  - 사전에 표준 용어 목록을 정의하여 데이터 항목 간 중복/혼동 방지
  - 컬럼명 규칙
    - 영문 소문자, 언더스코어 구분법 사용 권장
    - 복합어 순서는 의미적 흐름대로 배치
   
- 데이터 항목 추출
  - ERD 또는 요구사항 정의서에서 다음과 같은 항목을 추출
    - 엔티티명 : 테이블 명
    - 속성명 : 컬럼명
    - 기본키 여부
    - 외래키 여부 : FK 여부 및 참조 테이블 명시

- 데이터 형식과 규칙 정의
  - 데이터 형식 : VARCHAR, INTEGER
  - 필수 여부 : NOT NULL
  - 제약 조건 : UNIQUE
  - 유효성 규칙 : 정규표현식, 값 범위 등
  - 단위/도메인 : 단위 명시
 
- 도메인 정의 및 단위 명시
  - 반복되는 속성 형식은 도메인으로 별도 정의하여 재사용
  - ```
    [Domain - EmailAddress]
    - 데이터 형식: VARCHAR(100)
    - 유효성: 이메일 정규식 검사
    - 예: user@example.com
    ```

- 관리 및 변경 이력
  - 작성자, 최종 수정일, 변경 사유 등을 기록하여 추적 가능성 확보
 
#### 데이터 사전 실무
- API문서와 연계
- DB Migration 사전 작업
- 데이터 검증 및 품질 관리

## 개념적 모델링
#### 엔티티 도출
- 현실 세계의 객체를 데이터베이스에 맞게 구조화하는 작업
- 엔티티 : 데이터베이스에서 저장하고 관리해야 할 정보 단위
- 특징
  - 식별 가능성
  - 지속성
  - 속성 보유
  - 관계 가능성
- 엔티티 도출 방법론
  - 명사 추출 기법
    - 설명서, 요구사항 문서, 회의록, 사용자 인터뷰 등에서 명사 형태의 단어를 추출한 후, 정보로서 저장 가치가 있는지 검토
  - 질문 기반 도출
    - 이 정보 저장해야 할까?
    - 고유해야 할까?
    - 장기간 보관되어야 할까?
    - 이 개념에 대한 조회/수정/관리가 자주 발생할까?
  - CRUD 기반 판단
    - 해당 개체가 시스템 내에서 Create, Read, Update, Delete 중 최소 2가지 이상의 조작이 필요한가?
   
- 엔티티 분류 기준(기본/중심/행위)
  - 기본 엔티티 : 실세계 객체, 다른 엔티티가 이를 참조함
  - 중심 엔티티 : 트랜잭션 중심으로 발생하는 주요 비즈니스 기록 / 기본 엔티티로 하는 동작(행위)
  - 행위 엔티티 : 이벤트/로그/이력 등 활용 내역 저장 용도
 
- 도출된 후보 엔티티는 실제로 시스템 내에서 식별자(PK)를 생성할 수 있는지 검토

#### 관계 정의
- 서로 다른 엔티티 간의 상호작용 구조를 명시하는 단계
- 기본 유형
  - 1:1
  - 1:N
  - N:M
 
- 필수관계 : 관계가 반드시 존재해야 함
- 선택관계 : 관계가 없을 수도 있음 / null 허용

- 관계 표현 방식
  - n:m 관계는 중간 테이블(연결 엔티티)을 반드시 둔다.
 
- 관계 설계 시 고려할 사항
  - 관계 방향성 (양방향, 단방향 체크)
  - 관계 제약조건 ( 삭제 시 제약을 설정해 무결성 보장 )
  - 연결 테이블 필요 여부 (N:M일 때)
  - 성능 고려(관계가 너무 많으면 조인 비용 증가 -> 인덱스 설정, 조회 분리 전략 필요)
 
#### ERD
- 데이터베이스 구조를 시각적으로 표현한 다이어그램
- 엔티티, 속성, 관계로 표현
- 구성요소
  - 엔티티
  - 속성
  - 기본키
  - 외래키
  - 관계
 
- IE표기법
  - 가장 널리 사용되는 ERD 표기법
  - 엔티티 : 사각형으로 표현
  - 속성 : 타원형으로 표현하거나 생략
  - 관계선 : 엔티티 간 선으로 연결, 관계명을 표시
  - 카디널리티 : 관계선 양 끝에 숫자나 기호로 표기 / (1),(N),(0..1) 등
 
- UML표기법
  - 클래스 다이어그램 / 객체지향 설계를 위한 다이어그램
  - 엔티티 : 클래스 박스로 표현
  - 속성 : 클래스 내부 필드로 표현
  - 관계선 : 연관관계를 화살표로 표현
  - 카디널리티 : 선 옆에 숫자 표기
 
- 품질 검토 항목
  - 엔티티 명 명확성
  - 속성의 원자성
  - 관계 명확성
  - 키 제약 조건 -> 연결테이블은 PK가 없을 수 있음
  - 정규화 여부 : 중복 속성, 반복 속성 제거
 
## 논리적 모델링
- 사용자의 요구사항을 기반으로 식별된 엔티티와 속성 간의 관계를 정형화된 구조로 표현하는 과정
- 목적
  - 데이터 구조의 명확화
  - 중복 최소화
  - 도메인 정의
  - 개발 표준 수립

#### 속성 정의와 설계
- 속성은 엔티티가 가지는 구체적인 데이터 항목
- 구성 요소
  - 속성명
  - 도메인 : 허용되는 값의 범위 ('Y'/'N', 숫자(0~100), 문자열)
  - 데이터 타입
  - 제약조건
 
- 속성 분류
  - 기본 속성 : 실제 값을 가지는 속성
  - 파생 속성 : 다른 속성에서 계산된 값
  - 복합 속성 : 여러 속성으로 구성되는 속성 ( address : city,zip 포함 )
  - 다중값 속성 : 여러 값을 가질 수 있는 속성 (hobby) -> 정규화 시 별도 테이블로 분리
 
- 속성 도메인
  - 데이터의 일관성과 정합성을 보장
 
- nul 허용 여부 판단 기준
  - 필수 데이터 여부
  - 시스템 자동 생성 여부
  - 외부 연동 값 여부
 
#### 식별자 설계
- 엔티티의 각 인스턴스를 고유하게 구별할 수 있도록 해주는 속성
- 후보키
  - 엔티티를 식별할 수 있는 후보가 되는 모든 키 집합
  - UNIQUE
  - 테이블에는 여러 개의 후보키가 있을 수 있음
  - 기본조건 = 유일성과 최소성
 
- 기본키
  - 후보키 중 실제로 테이블의 주 식별자로 선택된 키
  - 테이블 당 하나만 존재
  - null값을 허용하지 않음
  - 기본키로 설정된 컬럼은 자동으로 INDEX 생성
 
- 대체키
  - 후보키 중 기본키로 선택되지 않은 나머지 키들
 
- 단일키
  - 하난의 컬럼으로 식별
  - 간결하고 인덱싱 효율적
  - 의미없는 surrogate key(인조키)일 수 있음
 
- 복합 키
  - 두 개 이상의 컬럼 조합으로 식별
  - 다대다 관계 테이블에서 자주 사용됨
  - 조합이 복잡할수록 관리 어려움
 
- 자연키
  - 실제 의미 있는 속성 (주민번호, 학번 등)
  - 사람도 이해 가능, 중복 관리 쉬움
  - 의미가 변경될 가능성 있음
  - 노출되수 있는 컬럼(노출되면 안되는 컬럼)을 기본키로 잘 사용하지 않음
 
- 인조키
  - 시스템이 부여한 의미 없는 키 (UUID)
  - 간결함, 변경 가능성 낮음
  - 사람이 해석하기 어려움
  - UUID는 난수라 정렬이 불가능 -> v4는 앞부분의 날짜와 시간이 들어가서 정렬이 일부 가능해 졌다
 
#### 정규화
- 데이터의 중복을 줄이고, 무결성을 높이기 위한 과정
- 삽입/수정/삭제 이상(Anomaly)을 방지하고 논리적으로 일관된 데이터 구조를 만드는데 목적이 있다.
- 중복 제거
- 무결성 향상
- 유지보수 용이성
- 정규화 유형
  - 1NF 모든 속성은 원자값만 포함 (중복 필드 제거, 원자성 보장)
  - 2NF 1NF + 모든 비키가 기본키에 완전 함수적 종속 (부분 종속 제거)
    - 기본키의 일부인 a로 비키인 b를 알 수 있는데 기본키의 다른 일부와 b가 무관하다.
    - ***학생ID, 과목, 교수*** 일때, (**학생ID, 과목**)이 기본키(복합키)일 때 **과목** 만으로 **교수**를 알 수 있는데 **기본키의 다른 일부 학생ID** 와 무관하다.
    - 이 때 2NF를 위반하고 있다
  - 3NF 2NF + 비키 간 이행적 종속 제거 (이행 종속 제거)
 
    | 주문ID | 고객ID | 제품ID | 제품명       | 제품가격 |
    |--------|--------|--------|--------------|----------|
    | 1      | 101    | 201    | 과일 바구니  | 20       |
    | 2      | 102    | 202    | 선물 세트    | 50       |
    | 3      | 101    | 203    | 초콜릿 상자  | 15       |
    | 4      | 103    | 201    | 과일 바구니  | 20       |
    | 5      | 104    | 202    | 선물 세트    | 50       |

    - 일 때, 주문ID가 기본키이다.
    - 그러나 제품ID를 알면 제품명과 제품 가격을 알 수 있다.
    - 이 때 3NF를 위반하고 있다. 테이블을 분리하여야 한다.
  - BCNF(3.5)
    - 기본키의 일부가 기본키 전체가 아닌 경우
    - 학생ID, 과목ID, 교수ID 일때, (학생ID, 과목ID)가 기본키
    - 과목ID가 교수ID를 결정하는데, 과목ID는 기본키의 일부이지만 기본키 전체는 아니다.
    - 과목ID와 교수ID 사이의 함수적 종속성을 별도의 테이블로 만들어야 한다.
   
- 필요 시 부분 반정규화도 고려(성능 향상을 위해)
